= Red Language Specification - draft
:imagesdir: /images
:toc:
:toclevels: 3
:numbered:

== Introduction

=== Purpose

The purpose of this document is to codify the lexical/syntactic and semantic rules
of the Red programming language, and thus to be the authoritative document for: 

* verifying implementation conformity
* tracking changes in the language design, including why changes were made
* acting as a reference for tests

In as much as feasible, and in order to avoid duplication, existing pieces
of official documentation will be referred to. A list of those can be found in
section _**Additional documentation**_.

This document is *not* intended to be used in order to learn the language (tutorial);
for that purpose sufficient materials can be found elsewhere
_** need one comprehensive and sufficiently maintained collection of links **_

=== Conventions

In this document, technical terms -- whether in general use or specific to the Red
language -- will be written in _italics_ when first used and sometimes also on
some subsequent occasions. Values from the Red language, grammatical categories,
rule numbers and Unicode Code Point numbers will be written in `monospace font`.

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter.
The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Overview

=== Characterization

Red is a next-generation programming language strongly inspired by Rebol,
but with a broader field of usage thanks to its native-code compiler,
from system programming to high-level scripting and cross-platform reactive GUI,
while providing modern support for concurrency. Red has its own complete cross-platform
toolchain, featuring two compilers, an interpreter and a linker,
not depending on any third-party library. Once complete, Red will be self-hosted.

_**The concurrency part is far from being implemented, mention it here?**_

=== Red toolchain

A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is constructed such that
the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

Information about the installation and usage of the toolchain can be found
in the README file of the https://github.com/red/red[Red repository on Github].
This repository contains the full source code of the toolchain, which may be
said to be the final authority on what the Red language is.

=== Values and types

An important property of Red is that any Red program is a _sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, execution of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_single values_), or _syntactically_ (_grouped
values_).

=== Words, contexts and binding

A special category of values is formed by _words_, that play
a similar role to identifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below, any _word_ may _refer_ to a value in some _context_.
The word is said to be _bound to_, or _in_ the context.
Initially, some words refer to certain values in the _global context_,
notably to _built-in functions_, _types_ (type names conventionally end in `!`)
and _constants_ such as the truth values: `true` and `false`, as well as `none`
("nil" or "null" in other languages). Evaluation of a word yields the value
it refers to. The evaluation rules given below will state,
amongst others, how words can come to refer to values in the course of
program execution.

=== Dialects

Red makes available a large number of different value types. The evaluation
rules stated below describe the interpretation of these values when they
occur in a Red _program_ which, as stated before, is nothing more or less
than a sequence of values.
The users may furthermore use and interpret Red values, when considered as _data_,
in ways of their own, and thus create _dialects_ or _Domain Specific Languages
(DSLs_).

In fact, Red itself contains a number of dialects where blocks of data are
interpreted in a specific way; this includes
the _parse dialect_, the _visual interface dialect (VID)_, which also uses
the _draw dialect_, the various _spec dialects_ involved in defining vectors,
images, bitsets, objects, errors, maps, operators, functions and routines,
furthermore the _compose dialect_ and the _system dialect_ (Red/System).

Red/System is on the one hand a language of its own: it is a C-level language
with memory pointer support and a very basic and limited set of datatypes.
Programs written in Red/System can be compiled and executed using the toolchain.
As a dialect of Red its purpose is to provide low-level system programming
capabilities, and it serves both as a tool to build Red's runtime library
and as intermediate language for the compiler to generate machine code from.
Red/System is specified in a separate document (see _**Additional documentation**_).

== Structure of Red programs

=== Textual structure

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to lexical analysis
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], #( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more _whitespace characters_. In the Red source text, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`)
and non-breaking space (`U+00A0`).

_**This is most certainly short of some whitespace values, please correct See also issue #2492**_

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive `block!`
values and between `word!` values and `block!` values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?   [1234]   [1234]

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described in section _**Metadata for the toolchain**_.

=== Formal grammar

A formal grammar corresponding to the above presentation is given below. As usual,
`*` means zero or more instances. The comment to any production rule, which starts after the `;` on the line,
states the type of the single or grouped values generated by this rule. Any non-terminal that is not
further defined in the grammar is explained in the individual sub-sections of section
_**Lexical structure of values**_ hereafter.

**`S100`**:: program structure

    <program>  ::= <prologue> <value>*
    <prologue> ::= Red [ <value>* ]
    <value>    ::= <lexeme> | <group>
    <lexeme>   ::= <integer>            ; integer!
             | <float>                  ; float!
             | <integer>% | <float>%    ; percent!
             | <integer>x<integer>      ; pair!
             | <time>                   ; time!
             | <tuple>                  ; tuple!
             | <word>                   ; word!
             | '<word>                  ; lit-word!
             | <word>:                  ; set-word!
             | :<word>                  ; get-word!
             | /<word>                  ; refinement!
             | #<word>                  ; issue!
             | <char>                   ; char!
             | <string>                 ; string!
             | <file>                   ; file!
             | <url>                    ; url!
             | <email>                  ; email!
             | <tag>                    ; tag!
             | <binary>                 ; binary!
             | <path>                   ; path!
             | '<path>                  ; lit-path!
             | <path>:                  ; set-path!
             | :<path>                  ; get-path!
    <group>    ::= <paren>
             | <block>
             | <map>
             | <constructor>
    <paren> ::=    ( <value>* )         ; paren!
    <block> ::=    [ <value>* ]         ; block!
    <map> ::=      #( <value>* )        ; map! (even number of values only)
    <constructor> ::= #[ <value>* ]     ; reserved for general typed value constructor


In what follows, terms like `<integer>` will be used to refer to lexemes;
to indicate the corresponding value, terms like "value of type `integer!`,
`integer!` value" or plain "integer" will be used.

=== Evaluation order

The constituents of a Red programs are in principle evaluated from left to right, according
to the evaluation rules given in the section _**Evaluation rules**_, with the following
peculiarities: certain function arguments are not evaluated before the function application
(see section _**Function types (rule E110)**_), and evaluation of the arguments of
_operators_ (values of type `op!` which represent binary infix functions) has precedence
over function application; operators are strictly _left associative_, there is no precedence
between any two operators. The arguments of a function simply follow the function itself,
they are not enclosed in parentheses, thus for the reader to understand a program,
knowledge of the _arity_ (number of arguments) of functions is necessary. Evaluation order
can of course be prescribed by the use of parentheses.

Some basic examples:
....
1 + 2 * 3                  <- result is 9, not 7
1 + (2 * 3)                <- result is 7
pick copy "abc" 1          <- 1 is argument to pick, since copy has 1 argument itself
copy/part "abc" 2          <- with the "refinement" /part, copy now has 2 arguments
mod x 2 + 1                <- mod has 2 arguments; this will be interpreted as mod x 3
1 + mod x 2                <- this is what was probably meant
(mod x 2) + 1              <- another way  of writing that
....

== Types

=== Type list
 
The full list of types of the languages is given below, with an explanation of the usage of their values.

....
type            usage of values

datatype!       types of the language (first class values)
typeset!        sets of types
none!           single value: none, i.e. a value belonging to none of the other types
logic!          true or false
char!           character (Unicode Code Point)
integer!        integer numbers 
float!          floating point numbers
percent!        id. expressed as a percentage
time!           time interval or point in time, stored as a floating point number of seconds
pair!           2-dimensional coordinates or size 
tuple!          color in RGB or other scheme, IPv4 adres
word!           identifier that can be bound
lit-word!       quoted (unevaluated) word
set-word!       word to be given a value to refer to
get-word!       word to be evaluated
refinement!     optional argument of function
issue!          literal identifier (word that does not refer to a value)
block!          ordered collection of values of any type (polymorphic array),
                may also be used as unordered collection (set)
hash!           block with quick access
paren!          differs from block in behaviour under evaluation  
path!           specifying optional arguments in function calls,
                selection of components of composite values
lit-path!       quoted (unevaluated) path
set-path!       for setting a component of a composite value
get-path!       path to be evaluated
vector!         ordered sequences of values of identical type, which can be
                char! or integer! (8/16/32 bits), percent! or float! (32/64 bits);
                default: 32 bits for char! or integer! and 64 bits otherwise
string!         sequence of characters (Unicode Code Points)
file!           file or directory (folder)
url!            URL
tag!            tag in the sense of HTML, XML etc.
email!          email-address
binary!         sequence of bytes
image!          2-dimensional array of pixels (RGBA values stored in 4 bytes each) 
bitset!         sequence of values true or false
map!            collection of pairs of values where the first value in each pair functions
                as key for retrieval of the second; keys are restricted to types in
                scalar!, all-word! and any-string!
object!         collection of word-value pairs with a context in which the words
                (also called fields) are bound, and refer to the corresponding values;
                objects are capable of triggering asynchronous events in response
                to changes in their components, thus enabling reactive programming;
                objects have a "class" property associated with them
error!          specialized objects representing error conditions
native!         pre-defined functions with built-in evaluation according to special rules
action!         pre-defined polymorphic functions of one or two arguments with built-in evaluation
op!             operators, i.e. infix functions of two arguments
function!       user-defined functions
routine!        user-defined functions with body in Red/System code
unset!          single value indicating the absence of a usable value
event!          representation of external activity   
handle!         opaque integer for communication with operating system
....

=== Type categories

As seen in the previous section, Red has a rather large number of different types.
For a better understanding of their nature and that
of their values, it is useful to make a number of distinctions into different categories.

* textual representation: types having lexically/syntactically representable values or not
* internal storage: _direct types_ vs _indirect types_ and _function types_
* internal structure of values: _atomic types_ vs _composite types_
* reflectivity: types with values that admit _reflection_  or not
* evaluation: _passive types_, _decaying types_, _active types_, _function types_
* implementation of built-in functions: _parent types_

==== Types according to their textual representation

Not all types listed have lexically or syntactically determined values. Those that have not
may have their values generally be represented in programs by
expressions of the form `make <type> <spec>`, where `<type>` is a type name and `<spec>`
is a value that is interpreted by the `make` function as appropriate for the given type.
This is explained in detail in section _**Creation of values (make)**_.
_**An alternative, syntactical representation,
will be offered for a number of types (or all??) in the form of construction syntax
`#[<type> <spec>]`**_.

==== Direct/Indirect/Function types

Red values are internally stored using _value slots_ of uniform size. Values of _direct types_
fit completely into one such slot; for values of _indirect types_, which have a variable number
of _components_, the slot stores a _pointer_ to a further storage area that holds the components
of the value. As a consequence, when a word ("variable") is made to refer to a value of indirect
type or such a value is supplied as argument to a function, the components of this value may
be changed through operations on the variable or the function argument.
In order to prevent this, values of indirect types must be explicitly copied before being
transmitted as argument or having a word refer to them. The built-in function `copy` will do this.
If the components themselves are of indirect type, `copy` will not copy their components,
unless the function refinement `/deep` is used. 

A third category to be distinguished is that of _function types_, where pointers to the argument
list and the body are stored in the slot.

==== Atomic/Composite types

Values of certain types have _components_ which may be extracted and/or changed using a variety of
facilities which will be specified below under evaluation. Such types are called _composite_ 
and the others are _atomic_. All indirect types are composite, but the converse
is not true: some direct types are also composite. However, component selection
in values of direct types cannot be used to change the component, only to extract it.
Making such a component refer to a new value results in a new instance of the direct value
being created, having the changed component.

==== Types that admit reflection

Values of some types have (internal) properties of interest to the user which may usefully be exposed.
E.g. the set of words from the word/value pairs making up an object may be retrieved by the built-in
function `words-of`. Likewise, the argument spec of a function may be retrieved by `spec-of`.

_** We should perhaps consider `context?` or rather `context-of` as a reflector also**_

==== Types according to the evaluation of their values

* Values of _passive types_ evaluate to themselves. The great majority of types belong to this category.
* Values of _decaying types_ are quoted instances of other values. They evaluate to the unquoted value.
* Values of _active types_ are bound to a context, their binding can be retrieved to yield the value referred to.
* Values of _function types_, when evaluated, result in the application of the function to its arguments.

Detailed rules for the evaluation in these various cases are given in section _**Evaluation rules**_. 

==== Parent types

The notion of _parent type_ arises in the implementation of _actions_, i.e. pre-defined polymorphic
functions of up to two arguments with built-in evaluation, e.g. `add`, `subtract`, `copy`, `find`, etc.
The implementation uses a _dispatch table_ which contains a pointer to a specific run-time
function for each allowed combination of action and type of first argument. These functions
are grouped by the type to which they apply. Now for any action/type combination,
such function may be designated as _inherited_ from the parent type, and in this way
two or more types may share the same implementation for that action.

_**Mention pseudo types `symbol`, `series!` and `context!`?**_ 

==== Overview table

....
type     value representation  direct (D)/      atomic (A)/   reflection     passive (P/        parent type
            lexical (L)/       indirect (I)/    composite (C)    (R)         decaying (D)/
            syntactic (S)/     function (F)     values                       active (A)/
            using make (M)/      storage                                     function (F)
            using words (W)                                                  evaluation
                                                                   
datatype!         W                 D                A                            P   
typeset!          M                 D                A                            P   
none!             W                 D                A                            P
logic!            W                 D                A                            P
char!             L                 D                A                            P              integer!
integer!          L                 D                A                            P
float!            L                 D                A                            P
percent!          L                 D                A                            P              float!
time!             L                 D                C                            P              float!
pair!             L                 D                C                            P
tuple!            L                 D                C                            P
word!             L                 D                A             R              A
lit-word!         L                 D                A             R (#2618)      D               word!
set-word!         L                 D                A             R (#2618)      A               word!
get-word!         L                 D                A             R (#2618)      A               word!
refinement!       L                 D                A             R (#2618)      P               word!
issue!            L                 D                A             R (#2618)      P               word!
block!            S                 I                C                            P
hash!             M                 I                C                            P               block!
paren!            S                 I                C                            A               block!
path!             L                 I                C                           A+F              block!
lit-path!         L                 I                C                            D               path!
set-path!         L                 I                C                            A               path!
get-path!         L                 I                C                            A               path!
vector!           M                 I                C                            P               string!
string!           L                 I                C                            P
file!             L                 I                C                            P               url!
url!              L                 I                C                            P               string!
tag!              L                 I                C                            P               string!
email!            L                 I                C                            P               string!
binary!           L                 I                C                            P               string!
image!            M                 I                C                            P
bitset!           M                 I                C                            P
map!              S                 I                C             R              P
object!           M                 I                C             R              P
error!            M                 I                C             R              P(note)         object!
native!           W                 F                A             R              F
action!           W                 F                A             R              F               native!
op!              W+M                F                A             R              F               native!
function!         M                 F                A             R              F
routine!          M                 F                A             R              F               function!
unset!            M                 D                A                            P
event!            W                 D                C                            P
handle!           W                 D                A                            P               integer!
....
Note: `error!` values evaluate to themselves, but raise an error in addition. See _**Errors**_

=== Type hierarchy

For the convenience of the user, certain typesets have been pre-defined
which group related types. These will notably be used for indicating
the allowed types of arguments to polymorphic functions. E.g. `power` takes
two arguments whose types are both in the typeset `number!`.

....
any-type!              
|--default!              
|  |--immediate!         
|  |  |--datatype!        
|  |  |--typeset!         
|  |  |--none!            
|  |  |--logic!           
|  |  |--scalar!          
|  |  |  |--char!          
|  |  |  |--number!        
|  |  |  |  |--integer!     
|  |  |  |  |--any-float!   <---- see issue #2565
|  |  |  |     |--float!     
|  |  |  |     |--percent!   
|  |  |  |--time!          
|  |  |  |--pair!          
|  |  |  |--tuple!         
|  |  |--any-word!
|  |  |  |--word!          
|  |  |  |--lit-word!      
|  |  |  |--set-word!      
|  |  |  |--get-word!      
|  |  |--refinement!    
|  |  |--issue!         
|  |--series!            
|  |  |--any-block!       
|  |  |  |--any-list!      
|  |  |  |  |--block!       
|  |  |  |  |--hash!        
|  |  |  |  |--paren!       
|  |  |  |--any-path!      
|  |  |     |--path!        
|  |  |     |--lit-path!    
|  |  |     |--set-path!    
|  |  |     |--get-path!    
|  |  |--vector!          
|  |  |--any-string!      
|  |  |  |--string!        
|  |  |  |--file!          
|  |  |  |--url!           
|  |  |  |--tag!           
|  |  |  |--email!         
|  |  |--binary!          
|  |  |--image!           
|  |--bitset!            
|  |--map!               
|  |--any-object!        
|  |  |--object!          
|  |  |--error!           
|  |--any-function!      
|     |--native!          
|     |--action!          
|     |--op!              
|     |--function!        
|     |--routine!         
|--internal!            
   |--unset!             
   |--event!             
   |--handle!            
....

== Values

=== Introduction

The types whose names are mentioned in rule `S100` (`integer!` to `map!`) are the only ones
that have lexically or syntactically determined values. Values that are not lexically
or syntactically determined may generally be represented in programs with the help
of the built-in function `make`. This is one of three related means that Red provides
in order to produce new values:

* creating them with the help of other ones (built-in function `make`)
* converting values to related ones of other types (built-in function `to`)
* changing their type without changing their content (built-in function `as`)

All three built-in functions have two arguments: `<type>` and `<spec>`,
where `<type>` evaluates to a type (`datatype!` value) or to a value (_prototype_)
of the desired type and `<spec>` is interpreted as appropriate for the given type. 

For several types, the available values are referred to by words at program start: `none!` has `none`,
`logic!` has `true = yes = on` and `false = no = off`, and `datatype!` has all the valid
type names pre-defined; likewise `native! action!` and `op!` have all the built-in functions
and operators pre-defined. Values of types `event!` and `handle!`, that are used to
communicate with operating system, can only be represented by words that are arguments to functions
handling this communication.

_**Mention general typed value constructor #[ <type> <value>* ]**_

The following sub-sections will specify the lexical structure resp. the `<spec>` argument
of the `make`, `to` and `as` function for values of each of the types as appropriate.

=== Lexical structure of values

==== `integer!`

**`S101`**::
An `integer!` value is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
_**Hexadecimal notation, eg FFh, is omitted as this is under discussion**_

Examples: `123`, `-123`, `+0001`, `1'000`

==== `float!`

**`S102`**::
A `float!` value is written as a signed floating point number in the range of the IEEE 754 binary64 format,
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`.
The number may be followed by `E` or `e` with a signed integer exponent on base 10.
Note that in this case, no decimal point is required.

Examples: `1.23`, `-0.5`, `.5`, `+010.20`, `1E9`

==== `time!`

**`S103`**::
....
    <time> ::= <hmsd> | +<hmsd> | -<hmsd>
    <hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
               <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any unsigned `<integer>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

Examples: `10:20`, `10:20:30.456`, `20:30.5`, `-1:00:00`

==== `tuple!`

**`S104`**::
A `tuple!` value is written as 3 to 12 `integer!` values in the range `0..255` separated by dots `.`

Examples: `192.168.1.2` (an IPv4 address), `255.255.128` (an RGB value)

==== `word!`

**`S105`**::
A `word!` value is written as one or more characters from the entire Unicode range excluding control characters
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # $ % @ : ;`.
A `word!` value does not begin with `0-9` or `'`.
Words are _case-insensitive_, i.e. changing any letter in the word into the corresponding upper- or lower-case
variant does not create a different word.

Examples: `abc`, `Abc`, `ABC`, `+`, `<>`, `integer!`, `last-item?` ; the first three are the same `word!` value.

Note: punctuation characters from the ASCII subset that *are* allowed in words are: `! & ' * + - . < = > ? _ `` `| ~`.

==== `char!`

**`S106`**::
....
    <char> :: = #"<single-character>"
    <single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
    <escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) |
                          ^(esc) | ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
    <hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....
where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

A `char!` value must be a valid single Unicode code point, i.e. an integer in the range `0` to `10FFFFF` (hexadecimal notation). 

A `<viewable character>` is, in most cases, simply a displayable character. For example, `e`, `é`, `€` or `😀`.
When a displayable character requires two or more graphemes to display it, each grapheme requires a separate Red character.
For example, when `é` is encoded in its two character decomposed form `e` (`U+0065`) followed by
the combining `´` (`U+0301`) they cannot be considered a single `char!` value, and programs must
explicitly handle their interpretation. 

The correspondence between the escaped characters and Unicode Code Points is given in the table below.

     Named Form   Short Form    Character           Code Point
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form (the beginning of)
an `<escaped-character>` or `<hexadecimal-codepoint>`. Thus e.g. `^3` yields the same as `3`.

Examples: `#"A", #"^/", #"^(0A)"`

==== `string!`

**`S107`**::
....
     <string> ::= "<single-character>*" | {<single-character>*}
....

where `<single-character>` is defined in rule `S106`

When the `<string>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `}`
character that is part of the `<string`> must be escaped by preceding it with `^`. Within a `<string>`,
the same remark holds for `^` as noted above for a `<char>`. 

Examples: `"abc^/def", {abc` +
`def}`

==== `file!`

**`S108`**::

A `file!` value is written as `%` followed by one or more non whitespace characters, or by zero or more
characters enclosed in `"  "` in which case whitespace characters except line feed and next line may be
included. The interpretation of this value is operating system dependent, but escaped characters of the
form `%<hex>` are accepted and converted.

==== `url!`

**`S109`**::

A `url!` value is written as three or more non whitespace characters, of which at least one `:` which must not
be the first or last character. Escaped characters of the form `%<hex>` are accepted and converted.

==== `email!`

**`S110`**::

An `email!` value is written as two or more characters containing one `@` but not beginning with it.
Escaped characters of the form `%<hex>` are accepted and converted.

==== `tag!`

**`S111`**::

A `tag!` value is written as zero or more characters, not starting with `<`, `=` or `>`, enclosed in `< >`.
Characters `"` and `'` are allowed but must each be properly paired and nested.

==== `binary!`

**`S112`**::
....
    <binary> ::= 2#{<base2-byte>*} | #{<hex>*} | 16#{<hex>*} | 64#{<base64-char>*}
....

where `<base2-byte>` is a group of 8 digits `0` or `1`, `<hex>` is defined in rule `S106`
and `<base64-char>` is a single character from the set `A-Z a-z 0-9 + /`; the individual elements within
the `#{ }` brackets (`<base2-byte>`, `<hex>` or `<base64-char>`) may be separated from the
brackets and from each other by whitespace.

Examples: `2#{00000001 00000010 00000011}, \#{ 01 02 03 }, 64#{AQID}`

==== `path!`

**`S113`**::
....
    <path> ::= <path-head>/<selector>
    <path-head> ::= <word> | <path>
    <selector> ::= <integer> | <word> | :<word> | <paren>
....

Examples: `list/1/2`, `system/view/screens/2`, `list/:i`, `list/(i)`, `copy/part`

=== Creation of values (`make`)

For some types, the values can *only* be introduced in a program as a
result of the `make` function. This section deals first of all with the types
for which that is the case, and with `map!` which has a "parallel"
syntactic form of its own. The make function can also be used
to construct values of other types. This is dealt with in the
latter part of the section.

Note that `make` evaluates its arguments. In this section, therefore,
non-terminals like `<integer>` do not stand for a literal integer
but for a value (to be evaluated) of `integer!` type etc.
Note also that, as stated above, the first argument of `make` does not
have to be a `datatype!` value; if it is a value of another type,
that type is taken to be the desired type. This is not made explicit
in the following rules, except in the case of `make object!` where
an `object!` value as second argument has a different interpretation.
In the case of `make error!` only the type `error!` is allowed as first argument
_**See issue 2640**_.

In the following rules, the sign `°` signifies an optional element.

==== `typeset!`

**`S114`**::
....
<typeset> ::= make typeset! [<typeset-element>*]
<typeset-element> ::= <typeset> | <datatype>
....

Examples: `number!` is defined as `make typeset! [integer! float! percent!]`,
`scalar!` is defined as `make typeset! [char! number! time! pair! tuple!]`.

Note that an empty typeset is allowed (`make typeset! []`).

==== `hash!`

**`S115`**::
....
<hash> ::= make hash! <block> 
....
The contents of the `<block>` are copied (not deeply).

==== `vector!`

**`S116`**::
....
<vector> ::= make vector! <vector-spec>
<vector-spec> ::= <integer> | <block> | [ <type-and-size> <block>]
<type-and-size> ::= char! 8 | char! 16 | char! 32 |
                    integer! 8 | integer! 16 | integer 32! |
                    float! 32 | float! 64 | percent! 32 | percent! 64
....
The `<integer>` should be non-negative. It produces an empty `vector!` value with the prescribed
number of components of type `integer!` and size 32 being allocated _** and set to zero **_.
The components of the `<block>` should all have the same type `char! integer! float!` or `percent!`. 
If `<type-and-size>` are omitted, type is deduced from the contents of `<block>`, and size is
the default size (32 for `char!` and `integer!`, 64 otherwise). If `<block>` is empty, the assumed type
is `integer!` of size 32.

Examples: `make vector! [], make vector! [integer! 16 [1 2 3]], make vector! [#"a" #"b" #"c"]`

==== `image!`

**`S117`**::
....
<image> ::= make image! <image-spec>
<image-spec> ::= <pair> | [<pair> <tuple>] | [<pair> <binary>] | [<pair> <binary> <binary>] 
....
If `<image-spec>` is `<pair>`, the image is created with the given dimensions, and with all pixels having color
`255.255.255` and transparency `0`. If a `<tuple>` is specified, this determines the color of all pixels,
transparency being `0`. If a single `<binary>` is specified, this should contain the array of colors of all pixels
(three bytes per pixel, stored by horizontal line), the transparency being `0`. The second `<binary>`, if present,
contains the transparency (one byte per pixel, in the same ordering).

Examples: `make image! 200x300, make image! [200x300 255.0.0], make image! [2x2 #{FFFFFFCCCCCCBFBFBF0C0C0C} #{00000000}]`

==== `bitset!`

**`S118`**::
....
<bitset> ::= make bitset! <binary> | make bitset! <bitset-spec> | charset <bitset-spec>
<bitset-spec> ::= <integer> | <char> | <string> | [<bit-position>*] | [not <bit-position>*]
<bit-position> ::= <integer> | <char> | <string> | <char> - <char> | <integer> - <integer>
....

A `<binary>` produces a `bitset!` value that is bit-by-bit equal to the `binary!` value.
The difference between `binary!` and `bitset!` is that `binary!` values have components
that are integers `0..255`, with 1-origin index, while `bitset!` values have components
that are `logic!` values (`true = 1, false = 0`), with 0-origin index.
The built-in function `charset` is defined as shorthand for `make bitset!`,
except that `<binary>` is not allowed as its argument. The `<bitset-spec>` that is
an `<integer>` produces an "empty" bitset (all bits set to false) of size the nearest
multiple of 8. In all other cases the `<bitset-spec>` provides a list of bit-position numbers,
or ranges of them, that are to be set to `true`. The `<char>` is interpreted as the Unicode Codepoint number.
A `<string>` is interpreted as the collection of all its component characters.
The length of the bitset is computed as the smallest multiple of 8 needed to fit the highest
bit number (0-origin). An "empty" bitset created by `[ ]` is 8 bits (one byte) long.
A `<bitset-spec>` that is a block starting with `not` produces the bit-by-bit complement of the bitset
produced by the following bit-position numbers, while actually storing only these bit-positions.

Examples: `make bitset! 16, charset "abc", charset [#"A" - #"Z" #"a" - #"z"]`

==== `object!`

**`S119`**::
....
<object> ::= make object! <object-spec> | object <object-spec> | context <object-spec> |
             make <value> <object-spec>
<object-spec> ::= <block>
....

The built-in functions `object` and `context` are defined as shorthand for `make object!`.
The `<value>` must be a value of type `object!`.

If the first argument to `make` is `object!` this creates a new object as follows.
A new context is created and associated to the object. The words of the new context
(i.e. the fields of the object) are the words of all the `set-word!` values that are
(first-level) components of the `<object-spec>`. The corresponding values are set
to the unset value. The `<object-spec>` is bound to this context (see section
_**Built-in bind function**_). The bound block is then _executed_.
The `class` property of the newly created object is set to a unique integer.

If the first argument to `make` is an `object!` value, it serves as "prototype".
A new object is created whose associated context is a copy of the prototype's context.
The `set-word!` values that are (first-level) components of the `<object-spec>`
are added to this context if they are not already present in that context.
The `<object-spec>` is then treated as in the previous case.
The `class` property of the new object is copied from the prototype.

==== `error!`

**`S120`**::
....
<error> ::= make error! <error-spec>
<error-spec> ::= <integer> | <block> | <string>
....

For the fields of an `error!` value, and the structure of the error repertoire
(`system/catalog/errors`) see section _**Errors**_.

If the `<error-spec>` is an `integer!` value, it is used to find values for the `type`
and `id` fields of the `error!` value which result in the `code` with that `integer!`
value. The values of these two fields are then bound as described in section _**Errors**_.

If the `<error-spec>` is a `block!` value, it should either contain two `word!` values
which will be used for the `type` and `id` value of the intended `error!` value, or
it should be an `<object-spec>` containing at least `type:` and `id:` fields;
in the former case, the `type` and `id` values will be bound as described in section _**Errors**_;
in the latter case, the `<block>` will be treated as described under rule `S119`;
note that also in this case, the `<block>` will be executed.

Except in the case where an `<object-spec>` is provided, any fields other than `type` and `id`
cannot be set by `make`. They should be set afterwards.

If the `<error-spec>` is a `string!` value, this will be used as `arg1` for the error with
`type: 'user id: 'message`. 

Note that `error!` values all have `class = 0`.

==== `function!`

**`S121`**::
....
<function> ::= make function! [<function-spec> <function-body>] | func <function-spec> <function-body> |
               has [<argument>*] <function-body> | does <function-body> | function <function-spec> <function-body>
<function-spec> ::= [<docstring>° <argument-spec> <return-spec>°]
<docstring> ::= <string>
<argument-spec> ::= <argument>* <optional-argument>*
<argument> ::= <argument-name> <argument-doc>° | <argument-name> [<typeset-element>*] <argument-doc>°
<argument-name> ::= <word> | '<word> | :<word>
<argument-doc> ::= <string>
<optional-argument> ::= <refinement> <argument-doc>° <argument>*
<refinement> ::= /<word>
<return-spec> ::= return: [<typeset-element>*]
<function-body> ::= <block>
....
For `<typeset-element>` see rule `S114`.

The `<docstring>` may be used to document the purpose and working of the function. Each `<argument-doc>`
may be used to document the purpose and usage of the associated  `<argument>`. When present, the type(set)s
of each `<argument>` will be used to check the type of the actual argument supplied.
Likewise, when present, the type(set)s of the `<return-spec>` will be used to check the type of the result.
_**This is not yet implemented!**_
The optional argument `/local` is conventionally used to list the local words of the function.
It is normally put after any other optional arguments (in fact the built-in `help` function
expects this to be the case).

The built-in function `func` is defined as shorthand for `make function!`. The built-in function
`has` is defined as shorthand for a function without other arguments than local words, thus
`has [<arguments>] <block>` is equivalent to `func [/local <arguments>] <block>`.
The built-in function `does` is defined as shorthand for `func [ ]` (no arguments at all).
The built-in function `function` is similar to `func` but it adds all set-words
found in the body to the list of local arguments.

==== `routine!`

**`S122`**::

....
<routine> ::= make routine! [<routine-spec> <routine-body>] | routine <routine-spec> <routine-body>
<routine-spec> ::= [<docstring>° <routine-argument>* <locals>° <routine-return>°]
<routine-argument> ::= <word> <argument-doc>° | <word> [<type>] <argument-doc>°
<locals> ::= /local <routine-argument>*
<routine-return> ::= return: [<type>]
<routine-body> ::= <block>
....
For `<docstring>` and `<argument-doc>` see rule `S121`. Note that routines
do not have optional arguments, except `/local`. Note also that arguments
and return spec must have a single type specified.

The built-in function `routine` is defined as shorthand for `make routine!`.

Values of type `routine!` may not occur in programs submitted to the interpreter.
When compiling, the toolchain will convert the routine into a Red/System function as follows:
the `<routine-spec>` is converted into a Red/System function specification block
by changing every Red type mentioned in it, except `integer! logic!` and `float!`
to the corresponding Red/System `struct!` alias that describes the value slot,
thus `string!` becomes `red-string!` etc.; an argument without a type is given
Red/System alias `red-value!` which corresponds to `any-type!`; the `<routine-body>`
(which lexically consists of Red values) becomes the body of this Red/System function,
and will be treated as Red/System code. The function thus constructed becomes part
of the intermediate Red/System code that the toolchain produces internally
for compilation into machine code.

The construction of routines requires a fairly deep knowledge of the Red runtime system
and the representation and storage of argument and result values.

==== `op!`

**`S123`**::
....
<op> ::= make op! <function> 
....

In contrast to `action!` and `native!` values which cannot be made by means of
`make`, the user may create new infix functions of two arguments (operators),
using `make op!`. The `<function>` should have exactly two arguments and no optional
arguments.

Example: `&&: make op! func [a b][all [a b]]`.

==== `map!`

A `map!` value can be produced both as grouped value and by `make`. The specification
is the same in both cases.

**`S124`**::
....
<map> ::= #(<map-spec>) | make map! [<map-spec>]
<map-spec> ::= <key-value-pair>*
<key-value-pair> ::= <key><value>
....

Each `<key>` should be a value of a type in `scalar!, any-word!` or `any-string!`.
All keys should be unique. If identical keys are encountered in the `<map-spec>` the value
corresponding to the last one encountered is taken. Keys of any type within `any-word!`
that do not differ in their symbol are considered identical for this purpose.

Note that values of `logic!` and `none!` type are not allowed as keys. Nevertheless
`true false` and `none` may occur in `<key>` position. Since the constituents
of `<map-spec>` are not evaluated, these words will be treated as `word!` values.
The same is true if they occur in `<value>` position.

==== other types 

* Making `integer!` and `float!` values from `logic!` values: `true -> 1/1.0, false -> 0/0.0` _**See issue 2644**_
* Making `logic!` values from `integer!` and `float!` values: `0/0.0 -> false, all else -> true`
* Making `time!` values from `block!` values: the block should contain three values (hours, minutes, seconds).
* Making a `series!` value from an `integer!` or `float!` value: the `float!` value is truncated; the integer
or truncated number is used to create an empty `series!` value with storage for the given number of components reserved.
This does not apply to `image!` values.

=== Conversion of values (`to`)

Conversion is possible for selected combinations of "source" and "target" type.
The list given below is meant to be exhaustive. A summary table is available
elsewhere (see section _**Additional documentation**_).

Note that for each type that may occur as target type, there is a built-in function
defined as shorthand: `to-integer <spec>` for `to integer! <spec>` etc.

==== Target types `none!` and `unset!`

The functions `to-none` and `to-unset` yield a `none!` resp. `unset!` value
for any argument value.

==== Target type `logic!`

The function `to-logic` yields `true` for any argument value except `none`. Note that
`to logic! 0` yields `true` whereas `make logic! 0` yields `false`! _**See issue #2645**_

==== Target types in `any-string!`

The function `to-string` yields the same result as the built-in function `form` (see
section _**Conversion from/to textual representation**_) except for

* `none!` values: conversion is not allowed
* `unset!` values:  yields empty string
* `binary!` values: these will be decoded as UTF-8
* `any-list!` values: the function will apply `form` to each component and concatenate the results

The functions `to-file` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target types in `any-list!`

The function `to-block` yields a block with the argument as single component except
for

* `string!` values: first applies `load` (see section _**Conversion from/to textual representation**_)
and applies `to-block` to the result
* `typeset!` values: yields a block with the individual types
* `any-block!` and `vector!` values: yields a block with the components
* `any-object!` and `map!` values: yields the same as `body-of`

The functions `to-paren` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target type `integer!`

The function `to-integer` is defined for

* `any-float!` and `time!` values: truncates the floating point value (seconds in the case
of `time!`) towards `0`
* `char!` values: yields the Unicode Code Point number
* `binary!` values: interprets the first 4 bytes as an integer (two's complement notation)
if there are fewer than 4 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error

==== Target types in `any-float!` and `time!`

The function `to-float` is defined for

* `integer!` values: yields the corresponding `float!` value
* `time!` values: yields the number of seconds
* `char!` values: yields the Unicode Code Point number as `float!` value
* `binary!` values: interprets the first 8 bytes as a floating point number (IEEE 754 binary64 format)
if there are fewer than 8 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain two components of type `integer!` or `float!`
the result is the first number times 10 to the power of the truncated second number

The function `to-percent` will perform the same conversions and yield a value of type `percent!.
The function `to-time` will do the same (except that a `block!` argument is not allowed)
and yield a `time!` value.

==== Target type `char!`

The function `to-char` is defined for

* `number!` values: yields the Unicode Code Point with the (truncated) number
* `binary!` values: assumes UTF-8 encoding; decodes as many bytes as necessary to obtain a Unicode Code Point
* `any-string!` values: yields the first character

==== Target type `pair!`

The function to-pair is defined for

* `integer!` and `any-float!` values: yields the pair with two components equal to the (truncated) number
* `any-list!` values: these should contain two `integer!` or `float!` values;
yields the pair wih the (truncated) numbers as components

Note that a similar built-in function `as-pair` of two arguments is defined,
which creates a pair out of the arguments.

==== Target type `tuple!`

The function to-tuple is defined for

* `binary!` values: yields the first 12 bytes or fewer as tuple components; if only 1 or 2 bytes are 
present, components `0` are added
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain only `integer!` or `float!` values in the range `0..255`;
yields the first 12 components or fewer as tuple components;  if only 1 or 2 values are 
present, components `0` are added

==== Target type `binary!`

The function `to-binary` is defined for

* `integer!` and `any-float!` values: yields the corresponding 4 resp. 8 byte binary value
* `char!` values: yields the 1 to 4 byte binary value corresponding to the Unicode Code Point number
* `tuple!` values: yields the 3 to 12 bytes binary value corresponding to the tuple components
* `bitset!` values: yields the corresponding binary value
* `string!` values: yields the UTF-8 encoded binary value
* `any-list!` values: these should contain only `integer!` or `float!` values;
the binary equivalents are concatenated, using as few bytes as needed
for each `integer!` value and 8 bytes for each `float! value
* `image!` values: yields a binary value with 4 bytes for each pixel

==== Target types in `any-word!` `refinement!` and `issue!`

The function `to-word` is defined for:

* `char!` values: makes a `word!` value with that single character
* `logic!` and `datatype!` values: yields the word that refers to the value
* `string!` values: yields the result of `load` or an error

The functions `to-lit-word` etc. perform the same conversiosn and yield
the result as a value of the appropriate type.

Note that `to-word none` does not yield the word `none`, it raises an error.

==== Target type `image!`

The function `to-image` is defined for `object!` values that are _faces_ i.e.
derived from the `face!` object which describes a window in the Red GUI system.
It yields the face such as it would be rendered on the screen, as an `image!`
value. See further the documentation of the GUI system (reference in section
_**Additional documentation**_).

=== Casting of values (`as`)

The casting facility applies to most of the `series!` types, and makes use of the fact
that values of several different but related types have their component values
stored in identical fashion. Therefore a change of type can be performed without copying
any component values. Two groups of related types are involved: `block! paren! any-path`
on the one hand, and `any-string!` on the other. The type of the second argument shoul
d be in the same group as the (type of the) first argument. The result is a new value
of the desired type, pointing to the components of the old value.
Note the absence of `hash!` from the first group, explained by the fact that `hash!`
values are stored differently from other `any-block!` values.

=== Components of values

Composite values can have their components extracted and changed by various means.

==== Indexing

Values that are sequences (with types in `series!` and `bitset!`)
admit indexing by integers, and images also by pairs as coordinates.
The lexical/syntactic form for this is `<path>` for extraction and `<path>: <value>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value to be indexed and `i` is the index, then `v/i` is equivalent to `pick v i`
and `v/i: x` is equivalent to `poke v i x`. Note that for lexical reasons, a `pair!` value as index
must be enclosed in parentheses, thus if `v` is an image, the pixel at 2x2 is addressed as `v/(2x2)`.
Note that `pick` and `poke` additionally allow the `logic!` values `true` and `false` as indexes:
`true ~ 1` and `false ~ 2`.

Values of type `time! pair!` and `tuple!` also admit component selection
by "indexing". In the case of `time!` values, which are stored as a `float!` number
of seconds, this selection proceeds by calculation (`1 ~ hour`, `2 ~ minute`, `3 ~ second`).
For `pair!` , `1 ~ x` (horizontal dimension, left to right) and `2 ~ y` (vertical dimension,
top to bottom). As stated in section _**Atomic/Composite types**_,
component selection in values of direct types cannot be used to change the component, only to extract it.
That is, only `<path>` and `pick` are allowed for these values.

The built-in functions `first second third fourth` and `fifth` are defined as `pick <value> 1` etc.

==== Selection by "key"

This is possible both for values that are sequences (with types in `series!`,
but not `bitset!`) and for values of types `object! error!` and `map!`.
The lexical/syntactic form for this is again `<path>` for extraction and `<path>: <value>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value from which to select and `k` is the key, then `v/k` is equivalent to `select v k`
and `v/k: x` is equivalent to `put v k x`.

The semantics of selection are different in the two cases (sequences vs. objects/maps).
For sequences, a `find` action is performed on the components using the key,
which should be a single value of the right type, or itself a sequence of such values,
and the first position where the key is found is marked. The result is then
the component *after* the found key (single or sequence). For the other types,
which contain key/value pairs, the result is the value corresponding to the given key.
In the case of `object!` and `error!` it is customary to call the keys _fields_.

Values of type `time! pair! email!` and `image!` also admit component selection
by specific words, and values of type `event!` have this as the only way of selection.
Again, for the direct types among them, only the `<path>` and `pick` forms are valid.

In case of `time! email! image!` and `event!`, the result is obtained by performing
a certain calculation.

* `time!` values: given a `float!` number of seconds, the `hour` and `minute` components
are the result of finding the whole number of `3600` seconds in the total, and then the
whole number of `60` seconds in the remainder; the `second` component is what remains after that
* `email!` values: the `user` component is the part before the `@` and the `host` component
is the part after the `@`
* `image!` values: the `size` component is the `pair!` value that holds the dimensions,
the `argb`, `rgb` and `alpha` components are the `binary!` sequences of RGBA, RGB and A values
respectively
* `event!` values: the components, which are explained in the Red GUi documentation
(see _**Additional documentation**_) are calculated in an OS-dependent way

==== Overview table

....
type         indexed      built-in    key values or types                built-in
             components   functions                                      functions

time!        1 2 3        pick        hour minute second                 --
pair!        1 2          pick        x y                                --
tuple!       1 .. 12      pick        --                                 --
any-block!   integer!     pick poke   any-type!                          select put
vector!      integer!     pick poke   integer! char!                     select (put see issue #1960)
any-string!  integer!     pick poke   char! any-string! binary!          select (put see issue #1960)
+ email!                              host user                          --
binary!      integer!     pick poke   integer! char! any-string! binary! select (put see issue #1960)
image!       integer!     pick poke   size rgb alpha argb                --
             pair!        pick poke
bitset!      integer!     pick poke   --                                 --
map!                                  scalar! all-word! any-string!      select put
object!                               word!                              select put
error!                                code type id arg1 arg2 arg3        select
                                           near where stack
event!                                type face window offset key        --
                                           picked flags away?
                                           down? mid-down? alt-down?
                                           ctrl? shift?
....

=== Reflection on values

Values of some types have (internal) properties of interest to the user which may
usefully be exposed.

This concerns first of all `(any-)word!` values for which information on their
binding may be obtained by means of two built-in functions: `context?` and `index?`.
These are explained in section _**Contexts**_. _**See issue #2618**_. 

_**What about `owner`??**_

For values of type `object! error!` and `map!`, which consist of key/value pairs,
the collection of keys, that of values, and the set of key/value pairs may each
be obtained as a block by means of the built-in functions `words-of values-of`
and `body-of`. In addition, for objects there is the property `class-of` which yields
a unique number which is given to each object that is created from a `<spec>`, and is
inherited by objects derived from it (see _**Values of map! type**_).

For `any-function!` values, one can obtain the full `<argument-spec>` through
the built-in function `spec-of` and the list of formal argument names through
the function `words-of` _**not yet implemented**_. For `function!` and `routine!` values, there is in
addition the function `body-of` which yields the function/routine body.

Note that the `help` built-in function is typically making good use of `spec-of`. 

=== Comparison of values

Red has the following operators and corresponding `native!` functions
for comparison of two values. Each of these operators/functions allows
arguments of any type, although in most cases the comparison may only
yield `true` if the two types are the same. Exceptions will be noted below.
The _equality_ functions, i.e. the first four, are defined for all types
of the first argument. The others (the _ordering_ ones) are only defined
for certain combinations of types. Also this will be noted.

....
    operator   native function

    =          equal?
    ==         strict-equal?
    =?         same?
    <>         not-equal?

    <          lesser?
    <=         lesser-or-equal?
    >          greater?
    >=         greater-or-equal?
....

==== Equality comparisons

The strictest equality test is `same?` which yields true only if the
two _value slots_ (see _**Direct/Indirect/Function types**_) have identical
content. For values of direct types this comes down to simple equality,
but for values of other types it is quite possible to be equal but not the same
(e.g. two strings of identical content, but stored in two different places).

For two values to succeed the `strict-equal?` test, TBD

==== Ordering comparisons

TBD

== Words, contexts and binding

=== Words

Red uses _words_ (values of type `word!`) to access values in much the same
way that other languages use variables. However, in Red, words do not
"store" values. Rather, a word _refers to a value_ in some _context_. i.e.
evaluating the word in that context yields the value. The word is said to be
_bound to_, or _in_ the context. Since functions, 
including built-in functions and operators, are also values in Red, the words
that refer to these values appear to work like keywords in other languages.

Thus all `word!` values have two important properties in this regard: their
symbol, that is their spelling (disregarding case), and the context they are
bound to. Something words *do not* have is a restriction on what values they
can refer to. In Red, values are strongly typed, but words, when used like
variables or keywords, are not.

For practical purposes, words are internally represented by three items:
a pointer to a context, an index in a symbol table which contains the symbol, 
and an index in the context which facilitates retrieving the value the
word refers to. Each occurrence of a word carries these three items
individually, and each occurence of a word with the same symbol can
therefore be bound to a different context, and refer to a different value.
Values of types `lit-word! set-word!` and `get-word!` (these types form
typeset `any-word!` with `word!`) have the same binding as the word
with the same symbol. Variables of types `refinement!` and `issue!`,
although not bindable, may share the same symbol.

=== Contexts

A _context_ in Red is a collection of word/value pairs. The words in
this collection are all different, and the values are the values the words
refer to. One can think of it as a table composed of two columns,
where the first is a list of unique symbols and the second contains
a corresponding value for each. Each word that is bound in this context
has its symbol and the value it refers to, positioned in a row of the
table. The value can be retrieved by finding the symbol, or by using
an index (row number) in the table. Note that such tables actually exist
in the implementation as values of an internal pseudo-type.

There is one _global context_ containing all words that have passed lexical
analysis as well as those that have been pre-defined in the toolchain, and
which refer to values such as built-in functions and constants. Words in the
global context that are not pre-defined, are considered "unset", which is a
special kind of value, distinct from `none`.

In addition to the global context, any number of contexts may exist during
program execution. Every _object_ (value of type `object!`) gives rise to a
context, containing the field-name/value pairs of the object. From an
implementation viewpoint, an object is just a combination of a context
and a class. Every _error_ (value of type `error!`) is a specialized object,
and therefore also has a context associated with it. Every function 
(value of type `function!`) also gives rise to a context, which contains
the pairs of formal argument name and actual argument value to be used by 
the body of the function when it is executed.

The user may access the context of a word reflectively through the built-in
function `context?` which can be applied to any word and will yield the
context the word is bound to. Since contexts themselves are not values
of a type of the langauge, they are yielded in the form of an object or function
as the case may be. The context of a word which is a field of an error value
is yielded as an object having the same field names and values as the error.
The global context is yielded as the object `system/words`. The index of a word
in its context may be obtained through the built-in function `index?`.

=== Binding

Words are bound to contexts as a result of:

* lexical analysis
- notably when the program containing the words is submitted to the toolchain
- or when a string representing some values, including words, is submitted to the REPL
- or through application of the built-in `load` function
* applying the built-in `set` function
* evaluating a `set-word!` value
* evaluating a `make object! <spec>` construct
* applying a function to its arguments
* applying the built-in `bind` function

Details of the binding process in these cases are given in the following sub-sections.

==== Lexical analysis

TBD

==== Setting words to values

The evaluation of `<word>: <value>` is treated in rule `E105`.
Equivalent to this is the application of the built-in function `set`:
`<word>: <value>` ~ `set '<word> <value>`. The full specification of `set` is as follows:
....
USAGE:
    SET word value /any /case /only /some
DESCRIPTION: 
    Sets the value(s) one or more words refer to 
    SET is a native! value
ARGUMENTS:
    word      [any-word! block! object! path!] "Word, object, map path or block of words to set"
    value     [any-type!] "Value or block of values to assign to words"
REFINEMENTS:
    /any      => Allow UNSET as a value rather than causing an error
    /case     => Use case-sensitive comparison (path only)
    /only     => Block or object value argument is set as a single value
    /some     => None values in a block or object value argument, are not set
RETURNS: 
     [any-type!] 
....

==== Object creation

This is treated in rule `S119`.

==== Function application

This is treated in rule `E110`.

==== Built-in `bind` function

The built-in function `bind` is a `native!` with the following specification:
....
USAGE:
    BIND word context /copy
DESCRIPTION: 
    BIND is a native! value
ARGUMENTS:
    word     [block! any-word!] 
    context  [any-word! any-object! function!] 
REFINEMENTS:
    /copy
RETURNS: 
     [block! any-word!] 
....

The function will try to change the binding of a single word or
of all words in a block, and will return the (modified) word or block.
It operates on values of type `word! lit-word! set-word!` and `get-word!`
(for brevity, called "words" in the rest of this section),
and will treat them at any depth within the block and its sub-blocks
(including values of type `paren! path! lit-path! set-path! get-path!` and `hash!`).

For each word to be treated it will search for the presence of an equally spelled
word in the given context, which is supplied in the form of a word
(whose context will be used), or of an object or error value or a function.
If an equally spelled word is found, the function will change the context
of the treated word to that given context and will adapt the index of the word;
otherwise, the word is left untouched.

With the `/copy` refinement the `block!` argument will be deep-copied before it
is modified.

A major application of this function is the binding of the formal arguments
of a function, as they occur within the function body, to the context which
contains the actual argument values. See evaluation rule `E110`.

== Input/output

=== Conversion from/to textual representation

=== Printing

=== File and Url I/O

== Evaluation rules

General remark: operator application has precedence over application of other functions
and over set-word target evaluation. Note that in Red all operators (values of type `op!`)
are binary infix functions. See further rule `E112`.

=== Passive types

**`E100`**:: For all values of passive types evaluation yields the value itself.
This is called the **identity rule**.

Note that `block!` is one of the passive types. Thus evaluation of a block
leaves the block unchanged. The term _execution of a block_ will be used to
indicate sequential evaluation of the components of the block; the result of this
execution is the result of the last evaluation, if any, and the unset value otherwise.

=== Decaying types

These are `lit-word!` and `lit-path!`.

**`E101`**:: Evaluating a `'<word>` results in its `<word>` counterpart.

**`E102`**:: Evaluating a `'<path>` results in its `<path>` counterpart.

=== Active types

==== `word!` type

**`E103`**:: Evaluating a `<word>` proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` raise an error and yield the unset value as result.
.. If the type is `error!` raise the error and yield the error value as result.
.. If the type is in `any-function!` apply the function (see rules `E110-114`).
.. Otherwise, the result is the value referred to.

Note: there are cases in which a `<word>` is not to be evaluated, e.g. when it occurs as
`<key>` or `<value>` in a `<map-spec>`, or when it is an actual argument to a function
where the formal argument is a `lit-word!`. In these cases, the predefined words `true false`
and `none` as well as the type names will be interpreted as `word!` values rather than as
`logic!` or `none!` values. To represent values of the desired type in such cases one may use
the generalized value construction syntax: `#[true], #[false], #[none]` etc.

==== `get-word!` type

**`E104`**:: Evaluating a `:<word>` proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` yield the unset value as result.
.. If the type is `error!` (raise the error and) yield the error value as result._**see issue 2621**_
.. Otherwise, the result is the value referred to.

Note that the difference with evaluating a `<word>` is that no errors are raised
and that a function value is not applied but is itself yielded as result.

==== `set-word!` type

**`E105`**:: Evaluating a `<word>:` outside an `<object-spec>` or a `<map-spec>`
has the effect that the `<word>` in its context
is made to refer to the value obtained by evaluating the next value(s). An error occurs
if no value is following or if the value obtained is unset. The result of the evaluation
is the value obtained. As a consequence, set-words may be "chained", thus: `a: b: c: 1`
is equivalent to `a: 1 b: 1 c: 1`.

==== `paren!` type

**`E106`**:: The evaluation of a `<paren>` proceeds by the evaluation of its component
values. The result is the value obtained from the last evaluation. This is similar to the
execution of a block. The following table compares parens and blocks.
....
expression          result of evaluation    comment
[1 + 2 3 + 4]         [1 + 2 3 + 4]         block! is passive type
do [1 + 2 3 + 4]      7                     do forces execution
(1 + 2 3 + 4)         7                     paren! is active type
quote (1 + 2 3 + 4)   (1 + 2 3 + 4)         quote inhibits evaluation
....

==== `path!` type

Recall the structure of `path!` values:

**`(S113)`**::
....
    <path> ::= <path-head>/<selector>
    <path-head> ::= <word> | <path>
    <selector> ::= <integer> | <word> | :<word> | <paren>
....

**`E107`**::

The evaluation of a `<path>` proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. Determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue 2578**_
.. If the result is a value of `any-function!` type, each following
`<selector>`, if any, should be an actual refinement of the function, i.e a `word!` value,
corresponding to one `<refinement>` present in the `<argument-spec>` of the function.
Evaluate the combination of the result and the actual refinements according
to the rules for values of function types (see section _**Function types**_).
.. If the result is of any other type, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the result is the component at the index given
by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
the result is obtained as in step iv hereafter. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
indirect type (except `image!`), an intermediate result is obtained by
applying the built-in function `select`
with as arguments the evaluated `<path-head>` and `<selector>`.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
direct type, `image!` or `event!`, an intermediate result is obtained as explained
in section _**Selection by "key"**_.
.. If a further `<selector>` is present, use the result just obtained as 
evaluated `<path-head>` and go to step 2, otherwise finish:
the result of the evaluation is obtained.

==== `get-path!` type

See also rule `E107`.

**`E108`**::
The evaluation of a `:<path>` value proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. Determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue 2578**_
.. If the result is a value of `any-function!` type, no following
`<selector>` is allowed and the result is the function value.
.. If the result is of any other type, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the result is the component at the index given
by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
the result is obtained as in step iv hereafter. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
indirect type (except `image!`), an intermediate result is obtained by
applying the built-in function `select`
with as arguments the evaluated `<path-head>` and `<selector>`.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
direct type, `image!` or `event!`, an intermediate result is obtained as explained
in section _**Selection by "key"**_.
.. If a further `<selector>` is present, use the result just obtained as 
evaluated `<path-head>` and go to step 2, otherwise finish and use
the intermediate result of the evaluation.

==== `set-path!` type

**`E109`**::
TBD

=== Function types

Values of `any-function!` type must be evaluated together with any
actual refinements (`word!` values that are found as `<selector>` in a `path!`
value whose `<path-head>` evaluates to the `any-function!` value). 

Recall the basic structure of the `<argument-spec>`, which is valid, with
soem limitations,  for all values of `any-function!` type:

**`(S121)`**::
....
<argument-spec> ::= <argument>* <optional-argument>*
<argument> ::= <argument-name> | <argument-name> [<typeset-element>*]
<argument-name> ::= <word> | '<word> | :<word>
<optional-argument> ::= <refinement> <argument>*
<refinement> ::= /<word>
....

==== `function!` type

**`E110`**::

The evaluation of a `function!` value (also called _function call_
or _function application_) proceeds as follows:

. If the function does not have any arguments (optional or not), execute
the body of the function to yield the result of the function.
. If the function has any arguments (optional or not), create a context specific
to this function value, with all the words (including values of type
`lit-word! get-word!` and `refinement!`) occurring in the `<argument-spec>`.
Make all these words initially refer to `none`.
.. Evaluate as many subsequent values as needed to obtain values corresponding
to the non-optional arguments, except that when the `<argument-name>`
is a `'<word>`, do not evaluate the corresponding value, and if the
`<argument-name>` is a `:<word>`, _**then do what??**_.
Make the `<word>` of each `<argument name>` refer to the corresponding value.
.. If actual refinements are present, match each of them with the corresponding `<refinement>`
in the `<argument-spec>`. Make the `<word>` of the `<refinement>` refer to `true`.
Furthermore, process each `<argument>` following the `<refinement>`
as in the previous sub-step, evaluating the necessary lexemes and inserting the values obtained in the context.
.. Bind the body of the function to the context (see section _**Built-in bind function**_).
.. Execute the body of the function to yield the result of the function.

Note that the order of the values to be supplied for the optional arguments is dictated
by the order of the actual refinements present, *not* by the order of the `<refinement>` s
in the `<argument-spec>`.

==== `action!` type

**`E111`**::
TBD

==== `op!` type

**`E112`**::
TBD

==== `native!` type

**`E113`**::
TBD

==== `routine!` type

**`E114`**::
TBD

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop

== Exceptions

Two kinds of exceptions (exceptional situations which disturb the normal
evaluation process) may be distinguished: _error exceptions_  or _errors_,
which arise in the course of evaluation because of inappropriate (combinations
of) values, and _user exceptions_ that are raised or "thrown" on conditions
determined by the user. An intermediate case is the _user error_ which is
also raised on conditions determined by the user but which is treated
like an error value.

=== Errors

==== Composition

Errors are values of type `error!` that can be produced as a result of
any evaluation; they are specialized objects with a fixed number of fields,
that contain the necessary information for identifying the nature and the place
of the error. A prototype error value is contained in `system/standard/error`.
As also shown in section _**Components of values**_ the fields are:
....
name     type           content

code      integer!       unique identifying number
type      word!          characterizes a group of errors
id        word!          identifier for the error within the group       
arg1      any-type!      additional information for the error message
arg2      any-type!      id.
arg3      any-type!      id.
near      block!         program fragment
where     any-type!      value whose evaluation triggered the error 
stack     integer!       machine address
....

Any field except `type` and `id` can also be `none`. If `arg1` is `none`
`arg2` and `arg3` will also be none`; likewise, if `arg2` is `none`,
`arg3` will also be `none`.

There is a fixed _repertoire_ of errors; identifying information
and (parametrized) error messages for each possible error are stored
in the object `system/catalog/errors`. This has the following sub-objects,
whose field names correspond to the contents of the `type` field
of the error value and which group related errors:
....
system/catalog/errors/...        code field  type field

throw                              0        "Throw Error"
note                             100        "note"
syntax                           200        "Syntax Error"
script                           300        "Script Error"
math                             400        "Math Error"
access                           500        "Access Error"
user                             800        "User Error"
internal                         900        "Internal Error"
....

As indicated in the table, each of the sub-objects has two fixed fields:
`code` which contains the base number for the codes of the individual
errors, and `type` which is a string that can be used in forming the
error message; this serves to sufficiently characterize the group.
Each sub-object has furthermore a number of fields, whose names
correspond to the `id` field of the error value, and which identify
the individual error. E.g. the `math` group has fields `zero-divide, overflow`
and `positive`. The contents of each of these fields is either a string,
which is a complete error message, or a block of strings and instances
of `:arg1, :arg2` and `:arg3`, which needs to be bound 
to the context of the error value, in order for the values of
`arg1` to `arg3` to be inserted; the block then can be used
to construct the error message. The full list of possible
errors is shown in section _**Errors list**_.

When the error value is produced,
the word which is the value of its `type` field is bound such that
it refers to the sub-object whose field name is that word;
also, the word which is the value of `id` field is bound such that
it refers to the error message (string or block) within that sub-object
whose field name is that word. Thus the following code will produce
the full message information for an error value, say `err`:
....
either err/arg1                             ; test if insertion is necessary
[
    reduce bind (get err/id) (in err 'id)   ; yields a block of strings and values
][
    get err/id                              ; yields a string
]
....

Examples:
....
system/catalog/errors/math is an object! of value:
     code             integer!  400 
     type             string!   "Math Error" 
     zero-divide      string!   "attempt to divide by zero" 
     overflow         string!   "math or number overflow" 
     positive         string!   "positive number required" 
system/catalog/errors/access is an object! of value:
     code             integer!  500 
     type             string!   "Access Error" 
     cannot-open      block!    ["cannot open:" :arg1] 
     invalid-utf8     block!    ["invalid UTF-8 encoding:" :arg1] 
     no-connect       block!    ["cannot connect:" :arg1 "reason: timeout"]
....

The `code` for each individual error is the base number + the ordinal number
of the error in the sub-object, e.g. for `no-connect` it is `502`.
_**Currently it is 504, is this correct?**_

==== Raising and interception

Errors are normally raised by the compiled code or by the interpreter,
as the case may be, but they can also be raised by evaluating a word
referring to an error value, by `make error! <spec>` or the built-in
function `cause-error`. The raising of an error will break off program
execution, unless it is intercepted by `try` or `attempt`.

The built-in function `try <block>` will execute the block and if there is
an error, it will yield that error value; otherwise it will yield the value
resulting from the execution. The built-in function `attempt <block>` will
apply `try` and if the result is an error value, it will yield `none`.

=== User exceptions

In contrast to errors, a user exception is not a value of the language,
but a call of a built-in function, which interrupst program execution
and may cause resumption at another place in the code, or result in
breaking off the execution like an unintercepted error does.

Three types of user exceptions exist:

* interruption of repeated execution (_loops_)
* interruption of function body execution
* "throws"

==== Interruption of loops

Red has a number of _loop_ constructs which cause repeated execution
of a block. _**Should they be described here??**_
In each of these, the block (_loop body_) may contain calls of the built-in functions
`break` and `continue`. A call of `break` will interrupt execution
of the body and resume directly after it. A call of `break/return <value>`
will in addition yield the `<value>` as a result of evaluating the loop.
A call of `continue` will interrupt execution of the body and resume
at the end of the body, potentially resulting in further cycles of execution.
Calls of these functions outside a loop body raise an error.

==== Interruption of function body execution

A call of the built-in function `exit` will interrupt execution of the
function body and resume in the code directly after the call.
A call of the built-in function `return <value>` will do the same
and yield the `<value>` as a result of the function body execution.
Calls of these functions outside a function body raise an error.

==== Throws

A _throw_ is a call of the built-in function `throw <value>` which will
interrupt execution and resume just after a corresponding call
of the built-in function `catch`, yielding the `<value>` as a result.

A _catch_, i.e. a call of the built-in function `catch <block>`,
will execute the block and if there are no throws during the execution,
it will yield the result of the execution as a value. If within the block,
including within the body of any function called within the block,
to any depth, there is a throw, the result of the catch
will be the value yielded by this throw.

For more control, `throw` has a refinement `/name` with a `word!` argument.
Correspondingly, `catch` has a refinement `/name` with as argument
a word or a block of words. A _named throw_ will only be reacted on
by a _named catch_ which has (amongst others) this name as argument,
or by a catch without a name. Other encompassing `catch` calls
will let it pass through.

If a throw is not caught by a catch, it will result in an error. 

==== Interception by `try`

The built-in function `try` (see _**Raising and interception**_) has
a refinement `/all`, allowing it to catch all possible forms of exceptions,
including `break`, `continue`, `exit` and `return` misuses as well as
uncaught throws.

== Preprocessor

== Pre-defined words list

=== constants
....
  characters
    comma
    CR
    dbl-quote
    dot
    escape
    lf
    newline
    null
    slash
    sp
    space
    tab
  floating point numbers
    pi
  logic! values
    false
    no
    off
    on
    true
    yes
  none! value
    none
  strings
    crlf
    font-fixed
    font-sans-serif
    font-serif
    p-indent
    value
  tuples (RGB color values)
    aqua
    beige
    black
    blue
    brick
    brown
    coal
    coffee
    crimson
    cyan
    forest
    glass
    gold
    gray
    green
    ivory
    khaki
    leaf
    linen
    magenta
    maroon
    mint
    navy
    oldrab
    olive
    orange
    papaya
    pewter
    pink
    purple
    reblue
    rebolor
    Red
    sienna
    silver
    sky
    snow
    tanned
    teal
    transparent
    violet
    water
    wheat
    white
    yello
    yellow
....
=== datatypes
....
    action!
    binary!
    bitset!
    block!
    char!
    datatype!
    email!
    error!
    event!
    file!
    float!
    function!
    get-path!
    get-word!
    handle!
    hash!
    image!
    integer!
    issue!
    lit-path!
    lit-word!
    logic!
    map!
    native!
    none!
    object!
    op!
    pair!
    paren!
    path!
    percent!
    point!
    refinement!
    routine!
    set-path!
    set-word!
    string!
    tag!
    time!
    tuple!
    typeset!
    unset!
    url!
    vector!
    word!
....
=== typesets
....
    all-word!
    any-block!
    any-function!
    any-list!
    any-object!
    any-path!
    any-string!
    any-type!
    any-word!
    default!
    immediate!
    internal!
    number!
    scalar!
    series!
....
=== natives
....
  enquiry
    complement?
    context?
    new-line?
    type?
    value?
  making
    compose
    construct
    reduce
  conversion
    debase
    dehex
    enbase
    lowercase
    uppercase
    to-hex
    to-local-file
  control
    break
    case
    continue
    either
    exit
    forall
    foreach
    forever
    if
    loop
    remove-each
    repeat
    return
    switch
    unless
    until
    while
  short-cut evaluation
    all
    any
  function definition
    does
    func
    function
    has
  math
    arccosine
    arcsine
    arctangent
    arctangent2
    checksum
    cosine
    exp
    log-10
    log-2
    log-e
    max
    min
    NaN?
    negative?
    positive?
    shift
    sign?
    sine
    square-root
    tangent
    zero?
  comparison
    equal?
    greater-or-equal?
    greater?
    lesser-or-equal?
    lesser?
    not-equal?
    same?
    strict-equal?
  set-operations
    difference
    exclude
    intersect
    union
    unique
  evaluation and binding
    as
    as-pair
    bind
    do
    get
    in
    set
    unset
  error handling
    catch
    throw
    try
  environment and OS related
    call
    get-env
    list-env
    now
    prin
    print
    set-env
    stats
    wait
  miscellaneous
    extend
    new-line
    not
    parse
....
=== actions
....
  general
    make
    random
    reflect
    to
    form
    mold
    eval-path
    compare
  scalar
    absolute
    add
    divide
    multiply
    negate
    power
    remainder
    round
    subtract
    even?
    odd?
  bitwise
    and~
    complement
    or~
    xor~
  series
    append
    at
    back
    change
    clear
    copy
    find
    head
    head?
    index?
    insert
    length?
    move
    next
    pick
    poke
    put
    remove
    reverse
    select
    sort
    skip
    swap
    tail
    tail?
    take
    trim
  I/O
    create
    close
    delete
    modify
    open
    open?
    query
    read
    rename
    update
    write
....
=== operators
....
             related action! (A)/native! (N)/
                routine! (R)/function (F)
    %        A remainder 
    *        A multiply
    **       A power
    +        A add
    -        A subtract
    /        A divide
    //       F modulo
    <        N lesser?
    <<       R shift-left <- N shift/left
    <=       N lesser-or-equal?
    <>       N not-equal?
    =        N equal?
    ==       N strict-equal?
    =?       N same?
    >        N greater?
    >=       N greater-or-equal?
    >>       R shift-right <- N shift
    >>>      R shift-logical <- N shift/logical
    and      A and~
    is       F is~ (hidden)
    or       N or~
    xor      N xor~
....
=== functions
....
  help
    ?
    ??
    about
    help
    source
    what
  enquiry
    action?
    binary?
    bitset?
    block?
    char?
    datatype?
    email?
    error?
    file?
    float?
    function?
    get-path?
    get-word?
    handle?
    hash?
    image?
    integer?
    issue?
    lit-path?
    lit-word?
    logic?
    map?
    native?
    none?
    object?
    op?
    pair?
    paren?
    path?
    percent?
    refinement?
    routine?
    set-path?
    set-word?
    string?
    tag?
    time?
    tuple?
    typeset?
    unset?
    url?
    vector?
    word?
    any-block?
    any-function?
    any-list?
    any-object?
    any-path?
    any-string?
    any-word?
    immediate?
    number?
    scalar?
    series?
    body-of
    class-of
    keys-of
    spec-of
    values-of
    words-of
    dir?
    empty?
    face?
  making
    charset
    context
    object
    routine
  conversion
    hex-to-rgb
    to-binary
    to-bitset
    to-block
    to-char
    to-email
    to-file
    to-float
    to-get-path
    to-get-word
    to-hash
    to-image
    to-integer
    to-issue
    to-lit-path
    to-lit-word
    to-logic
    to-map
    to-none
    to-pair
    to-paren
    to-path
    to-percent
    to-red-file
    to-refinement
    to-set-path
    to-set-word
    to-string
    to-tag
    to-time
    to-tuple
    to-typeset
    to-unset
    to-url
    to-word
  series
    alter
    extract
    fifth
    first
    fourth
    last
    offset?
    pad
    rejoin
    repend
    replace
    second
    split
    third
  math
    acos
    asin
    atan
    atan2
    cos
    math
    mod
    modulo
    sin
    sqrt
    tan
  GUI
    center-face
    clear-reactions
    distance?
    do-actor
    do-events
    do-file
    draw
    get-scroller
    insert-event-func
    layout
    overlap?
    remove-event-func
    request-dir
    request-file
    request-font
    set-focus
    show
    size-text
    unview
    view
    within?
  I/O
    cd
    change-dir
    clean-path
    dir
    dirize
    input
    list-dir
    ll
    load
    ls
    make-dir
    normalize-dir
    prin-out
    print-out
    probe
    pwd
    red-complete-file
    red-complete-input
    red-complete-path
    save
    split-path
    suffix?
    what-dir
  control
    also
    comment
    halt
    q
    quit
  miscellaneous
    collect
    quote
  reactivity
    react
    react?
  pre-processing
    expand
    expand-directives
  error handling
    attempt
    cause-error
  debugging
    do-safe
    dump-face
    dump-reactions
    on-parse-event
    parse-trace
....
=== routines
....
  enquiry
    event?
  conversion
    as-color
    as-ipv4
    as-rgba
  bitwise operations
    shift-left
    shift-logical
    shift-right
  control
    quit-return
    set-quiet
  GUI
    find-flag?
  I/O
    ask
    browse
    create-dir
    exists?
    get-current-dir
    last-lf?
    read-clipboard
    set-current-dir
    write-clipboard
    write-stdout
....
== Errors list

The format in each sub-section is
....
type (code base)
    id -> string or block
    etc. 
....

=== Throw Errors
....
throw ( 0 )
    break -> "no loop to break"
    return -> "return or exit not in function"
    throw -> ["no catch for throw:" :arg1]
    continue -> "no loop to continue"
....
=== Notes
....
note ( 100 )
    no-load -> ["cannot load: " :arg1]
....
=== Syntax Errors
....
syntax ( 200 )
    invalid -> ["invalid" :arg1 "at" :arg2]
    missing -> ["missing" :arg1 "at" :arg2]
    no-header -> ["script is missing a Red header:" :arg1]
    no-rs-header -> ["script is missing a Red/System header:" :arg1]
    bad-header -> ["script header is not valid:" :arg1]
    malconstruct -> ["invalid construction spec:" :arg1]
    bad-char -> ["invalid character in:" :arg1]
....
=== Script Errors
....
script ( 300 )
    no-value -> [:arg1 "has no value"]
    need-value -> [:arg1 "needs a value"]
    not-defined -> [:arg1 "word is not bound to a context"]
    not-in-context -> [:arg1 "is not in the specified context"]
    no-arg -> [:arg1 "is missing its" :arg2 "argument"]
    expect-arg -> [:arg1 "does not allow" :arg2 "for its" :arg3 "argument"]
    expect-val -> ["expected" :arg1 "not" :arg2]
    expect-type -> [:arg1 :arg2 "field must be of type" :arg3]
    cannot-use -> ["cannot use" :arg1 "on" :arg2 "value"]
    invalid-arg -> ["invalid argument:" :arg1]
    invalid-type -> [:arg1 "type is not allowed here"]
    invalid-type-spec -> ["invalid type specifier:" :arg1]
    invalid-op -> ["invalid operator:" :arg1]
    no-op-arg -> [:arg1 "operator is missing an argument"]
    bad-op-spec -> {making an op! requires a function with only 2 arguments}
    invalid-data -> ["data not in correct format:" :arg1]
    invalid-part -> ["invalid /part count:" :arg1]
    not-same-type -> "values must be of the same type"
    not-same-class -> ["cannot coerce" :arg1 "to" :arg2]
    not-related -> ["incompatible argument for" :arg1 "of" :arg2]
    bad-func-def -> ["invalid function definition:" :arg1]
    bad-func-arg -> ["function argument" :arg1 "is not valid"]
    bad-func-extern -> ["invalid /extern value:" :arg1]
    no-refine -> [:arg1 "has no refinement called" :arg2]
    bad-refines -> "incompatible or invalid refinements"
    bad-refine -> ["incompatible refinement:" :arg1]
    word-first -> ["path must start with a word:" :arg1]
    empty-path -> "cannot evaluate an empty path value"
    invalid-path -> ["cannot access" :arg2 "in path" :arg1]
    invalid-path-set -> ["unsupported type in" :arg1 "set-path"]
    invalid-path-get -> ["unsupported type in" :arg1 "get-path"]
    bad-path-type -> ["path" :arg1 "is not valid for" :arg2 "type"]
    bad-path-set -> ["cannot set" :arg2 "in path" :arg1]
    bad-field-set -> ["cannot set" :arg1 "field to" :arg2 "datatype"]
    dup-vars -> ["duplicate variable specified:" :arg1]
    past-end -> "out of range or past end"
    missing-arg -> "missing a required argument or refinement"
    out-of-range -> ["value out of range:" :arg1]
    invalid-chars -> "contains invalid characters"
    invalid-compare -> ["cannot compare" :arg1 "with" :arg2]
    wrong-type -> ["datatype assertion failed for:" :arg1]
    invalid-refine-arg -> ["invalid" :arg1 "argument:" :arg2]
    type-limit -> [:arg1 "overflow/underflow"]
    size-limit -> ["maximum limit reached:" :arg1]
    no-return -> "block did not return a value"
    throw-usage -> "invalid use of a thrown error value"
    locked-word -> ["protected word - cannot modify:" :arg1]
    bad-bad -> [:arg1 "error:" :arg2]
    bad-make-arg -> ["cannot MAKE" :arg1 "from:" :arg2]
    bad-to-arg -> ["cannot MAKE/TO" :arg1 "from:" :arg2]
    invalid-spec-field -> ["invalid" :arg1 "field in spec block"]
    missing-spec-field -> [:arg1 "not found in spec block"]
    move-bad -> ["Cannot MOVE elements from" :arg1 "to" :arg2]
    too-long -> "Content too long"
    invalid-char -> ["Invalid char! value:" :arg1]
    parse-rule -> ["PARSE - invalid rule or usage of rule:" :arg1]
    parse-end -> ["PARSE - unexpected end of rule after:" :arg1]
    parse-invalid-ref -> ["PARSE - get-word refers to a different series!" :arg1]
    parse-block -> ["PARSE - input must be of any-block! type:" :arg1]
    parse-unsupported -> {PARSE - matching by datatype not supported for any-string! input}
    parse-infinite -> ["PARSE - infinite recursion at rule: [" :arg1 "]"]
    parse-stack -> "PARSE - stack limit reached"
    parse-keep -> "PARSE - KEEP is used without a wrapping COLLECT"
    parse-into-bad -> {PARSE - COLLECT INTO/AFTER expects a series! argument}
    invalid-draw -> ["invalid Draw dialect input at:" :arg1]
    invalid-data-facet -> ["invalid DATA facet content" :arg1]
    face-type -> ["VIEW - invalid face type:" :arg1]
    not-window -> "VIEW - expected a window root face"
    bad-window -> {VIEW - a window face cannot be nested in another window}
    not-linked -> "VIEW - face not linked to a window"
    not-event-type -> ["VIEW - not a valid event type" :arg1]
    invalid-facet-type -> ["VIEW - invalid rate value:" :arg1]
    vid-invalid-syntax -> ["VID - invalid syntax at:" :arg1]
    react-bad-func -> {REACT - /LINK option requires a function! as argument}
    react-not-enough -> {REACT - reactive functions must accept at least 2 arguments}
    react-no-match -> {REACT - objects block length must match reaction function arg count}
    react-bad-obj -> "REACT - target can only contain object values"
    react-gctx -> ["REACT - word" :arg1 "is not a reactor's field"]
    lib-invalid-arg -> ["LIBRED - invalid argument for" :arg1]
....
=== Math Errors
....
math ( 400 )
    zero-divide -> "attempt to divide by zero"
    overflow -> "math or number overflow"
    positive -> "positive number required"
....
=== Access Errors
....
access ( 500 )
    cannot-open -> ["cannot open:" :arg1]
    invalid-utf8 -> ["invalid UTF-8 encoding:" :arg1]
    no-connect -> ["cannot connect:" :arg1 "reason: timeout"]
....
=== User Errors
....
user ( 800 )
    message -> [:arg1]
....
=== Internal Errors
....
internal ( 900 )
    bad-path -> ["bad path:" arg1]
    not-here -> [arg1 "not supported on your system"]
    no-memory -> "not enough memory"
    wrong-mem -> "failed to release memory"
    stack-overflow -> "stack overflow"
    too-deep -> "block or paren series is too deep to display"
    feature-na -> "feature not available"
    not-done -> "reserved for future use (or not yet implemented)"
    invalid-error -> "error object or fields were not valid"
    routines -> {routines require compilation, from OS shell: `red -c <script.red>`}
    red-system -> {contains Red/System code which requires compilation}
....

== Metadata for the toolchain

It is recommended to organize the metadata as `<word>: <value>` pairs. This
will facilitate storage and retrieval of these data by the toolchain as well
as the user. Certain elements of metadata, that are used by the toolchain,
*must* be in this format: `Needs:` and `Config:`, with prescribed types for
the `<value>` as indicated.

The following is a list of suggested and compulsory elements.

....
element     type           description

Title:      string!        application title
Purpose:    string!        short description of the application purpose
Author:     string!        source code author name
File:       file!          name of the source file
Version:    tuple!         source code version
Date:       date!          date of last version
Rights:     string!        copyrights
License:    [url! string!] source license (URL or full text)
History:    block!         source modifications history
Note(s):    string!        any special notice

Language:   word!          language of the comments
Tabs:       integer!       number of spaces between tab positions
Icon:       file!          *.ico file with icon for executable

Needs:      [word! block!] module(s) that is/are to be included
Config:     ???
....

== Additional documentation

The following is a list of official documents that complement the information given in this one.

. https://github.com/red/red/blob/master/README.md[README file for the toolchain]
. http://static.red-lang.org/red-system-specs-light.html[Red/System Language Specification]
. https://doc.red-lang.org/en/[Red Programming Language Documentation] notably:
  .. https://doc.red-lang.org/en/map.html[map! datatype]
  .. https://doc.red-lang.org/en/gui.html[GUI System]
  .. https://doc.red-lang.org/en/reactivity.html[Reactive Programming]
  .. https://doc.red-lang.org/en/preprocessor.html[Preprocessor]
. https://github.com/red/red/blob/master/docs/conversion-matrix.xlsx[Conversion matrix]
. http://www.red-lang.org/2013/11/041-introducing-parse.html[Introducing Parse] (blog article from 2013)
