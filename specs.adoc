= Red Language Specification - draft
:imagesdir: /images
:toc:
:toclevels: 3
:numbered:

== Introduction

=== Purpose

The purpose of this document is to codify the lexical/syntactic and semantic rules
of the Red programming language, and thus to be the authoritative document for: 

* verifying implementation conformity
* tracking changes in the language design, including why changes were made
* acting as a reference for tests

In as much as feasible, and in order to avoid duplication, existing pieces
of official documentation will be referred to. A list of those can be found in
section _**Additional documentation**_.

Because of the wealth of built-in functions that Red makes available, combined
with the numerous optional facilities ("refinements") that these functions have,
it is not possible to give an exhaustive treatment of Red's functionality.
Red allows quite detailed information about a function's operation to be
documented within the function specification, and this should be consulted
in order to be able to use any function optimally. See section _**Help facilities**_.

This document is *not* intended to be used in order to learn the language (tutorial);
for that purpose sufficient materials can be found elsewhere
_** need one comprehensive and sufficiently maintained collection of links **_

=== Conventions

In this document, technical terms -- whether in general use or specific to the Red
language -- will be written in _italics_ when first used and sometimes also on
some subsequent occasions. Values from the Red language, grammatical categories,
rule numbers and Unicode Code Point numbers will be written in `monospace font`.

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter.
The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Overview

=== Characterization

Red is a next-generation programming language strongly inspired by Rebol,
but with a broader field of usage thanks to its native-code compiler,
from system programming to high-level scripting and cross-platform reactive GUI,
while providing modern support for concurrency. Red has its own complete cross-platform
toolchain, featuring two compilers, an interpreter and a linker,
not depending on any third-party library. Once complete, Red will be self-hosted.

_**The concurrency part is far from being implemented, mention it here?**_

=== Red toolchain

A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is to be constructed
such that the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

Information about the installation and usage of the toolchain can be found
in the README file of the https://github.com/red/red[Red repository on Github].
This repository contains the full source code of the toolchain, which may be
said to be the final authority on what the Red language is.

=== Values and types

An important property of Red is that any Red program is a _sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, execution of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_single values_), or _syntactically_ (_grouped
values_).

=== Words, contexts and binding

A special category of values is formed by _words_, that play
a similar role to identifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below, any _word_ may _refer_ to a value in some _context_.
The word is said to be _bound to_, or _in_ the context.
Evaluation of a word yields the value it refers to. The evaluation rules
given below will state, amongst others, how words can come to refer
to values in the course of program execution.

A large number of words are _pre-defined_ to refer to certain values
in the _global context_, notably to _built-in functions_, _types_
(type names conventionally end in `!`) and _constants_ such as
the truth values: `true` and `false`, as well as `none` ("nil"
or "null" in other languages). See section _**Pre-defined words**_
for the complete list.

As regards the built-in functions, a number of them will be mentioned
in this document, and their basic operation explained. To find more
information about these functions, especially their various options,
and in general on all other functions or any Red value for that matter,
the built-in `help` function can be called from an interactive console.

=== Dialects

Red makes available a large number of different value types. The evaluation
rules stated below describe the interpretation of these values when they
occur in a Red _program_ which, as stated before, is nothing more or less
than a sequence of values.
The users may furthermore use and interpret Red values, when considered as _data_,
in ways of their own, and thus create _dialects_ or _Domain Specific Languages
(DSLs_).

In fact, Red itself contains a number of dialects where blocks of data are
interpreted in a specific way; this includes the _preprocessor dialect_, 
the _parse dialect_, the _visual interface dialect (VID)_, which also uses
the _draw dialect_, the various _spec dialects_ involved in defining vectors,
images, bitsets, objects, errors, maps, operators, functions and routines,
furthermore the _compose dialect_ and the _system dialect_ (Red/System).

Red/System is on the one hand a language of its own: it is a C-level language
with memory pointer support and a very basic and limited set of datatypes.
Programs written in Red/System can be compiled and executed using the toolchain.
As a dialect of Red its purpose is to provide low-level system programming
capabilities, and it serves both as a tool to build Red's runtime library
and as intermediate language for the compiler to generate machine code from.
Red/System is specified in a separate document (see _**Additional documentation**_).

== Structure of Red programs

=== Textual structure

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to lexical analysis
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], #( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more _whitespace characters_. In the Red source text, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`)
and non-breaking space (`U+00A0`).

_**This is most certainly short of some whitespace values, please correct See also issue #2492**_

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive `block!`
values and between `word!` values and `block!` values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?   [1234]   [1234]

_Comments_, which have no significance for the operation of the program, may be placed following
a semicolon `;` until the end of an input line, or they may follow the word `comment` and be
formulated as a single Red value -- most usefully a series of characters enclosed in `{ }` or
a series of Red values enclosed in `[ ]`.

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described in section _**Metadata for the toolchain**_.

=== Formal grammar

A formal grammar corresponding to the above presentation is given below. As usual,
`*` means zero or more instances. The comment to any production rule, which starts after the `;` on the line,
states the type of the single or grouped values generated by this rule. Any non-terminal that is not
further defined in the grammar is explained in the individual sub-sections of section
_**Lexical structure of values**_ hereafter.

**`S100`**:: program structure

    <program>  ::= <prologue> <value>*
    <prologue> ::= Red [ <value>* ]
    <value>    ::= <lexeme> | <group>
    <lexeme>   ::= <integer>            ; integer!
             | <float>                  ; float!
             | <integer>% | <float>%    ; percent!
             | <integer>x<integer>      ; pair!
             | <time>                   ; time!
             | <tuple>                  ; tuple!
             | <word>                   ; word!
             | '<word>                  ; lit-word!
             | <word>:                  ; set-word!
             | :<word>                  ; get-word!
             | /<word>                  ; refinement!
             | #<word>                  ; issue!
             | <char>                   ; char!
             | <string>                 ; string!
             | <file>                   ; file!
             | <url>                    ; url!
             | <email>                  ; email!
             | <tag>                    ; tag!
             | <binary>                 ; binary!
             | <path>                   ; path!
             | '<path>                  ; lit-path!
             | <path>:                  ; set-path!
             | :<path>                  ; get-path!
    <group>    ::= <paren>
             | <block>
             | <map>
             | <constructor>
    <paren> ::=    ( <value>* )         ; paren!
    <block> ::=    [ <value>* ]         ; block!
    <map> ::=      #( <value>* )        ; map! (even number of values only)
    <constructor> ::= #[ <value>* ]     ; reserved for general typed value constructor


In what follows, terms like `<integer>` will be used to refer to lexemes;
to indicate the corresponding value, terms like "value of type `integer!`,
`integer!` value" or plain "integer" will be used.

=== Evaluation order

The constituents of a Red programs are in principle evaluated from left to right, according
to the evaluation rules given in the section _**Evaluation rules**_, with the following
peculiarities: certain function arguments are not evaluated before the function application
(see section _**Function types (rule E110)**_), and evaluation of the arguments of
_operators_ (values of type `op!` which represent binary infix functions) has precedence
over function application; operators are strictly _left associative_, there is no precedence
between any two operators. The arguments of a function simply follow the function itself,
they are not enclosed in parentheses, thus for the reader to understand a program,
knowledge of the _arity_ (number of arguments) of functions is necessary. Evaluation order
can of course be prescribed by the use of parentheses.

Some basic examples:
....
1 + 2 * 3                  <- result is 9, not 7
1 + (2 * 3)                <- result is 7
pick copy "abc" 1          <- 1 is argument to pick, since copy has 1 argument itself
copy/part "abc" 2          <- with the "refinement" /part, copy now has 2 arguments
mod x 2 + 1                <- mod has 2 arguments; this will be interpreted as mod x 3
1 + mod x 2                <- this is what was probably meant
(mod x 2) + 1              <- another way  of writing that
....

== Types

=== Type list
 
The full list of types of the languages is given below, with an explanation of the usage of their values.

....
type            usage of values

datatype!       types of the language (first class values)
typeset!        sets of types
none!           single value: none, i.e. a value belonging to none of the other types
logic!          true or false
char!           character (Unicode Code Point)
integer!        integer numbers 
float!          floating point numbers
percent!        id. expressed as a percentage
time!           time interval or point in time, stored as a floating point number of seconds
pair!           2-dimensional coordinates or size 
tuple!          color in RGB or other scheme, IPv4 adres
word!           identifier that can be bound
lit-word!       quoted (unevaluated) word
set-word!       word to be given a value to refer to
get-word!       word to be evaluated
refinement!     optional argument of function
issue!          literal identifier (word that does not refer to a value)
handle!         opaque integer for communication with operating system
block!          ordered collection of values of any type (polymorphic array),
                may also be used as unordered collection (set)
hash!           block with quick access
paren!          differs from block in behaviour under evaluation  
path!           specifying optional arguments in function calls,
                selection of components of composite values
lit-path!       quoted (unevaluated) path
set-path!       for setting a component of a composite value
get-path!       path to be evaluated
vector!         ordered sequences of values of identical type, which can be
                char! or integer! (8/16/32 bits), percent! or float! (32/64 bits);
                default: 32 bits for char! or integer! and 64 bits otherwise
string!         sequence of characters (Unicode Code Points)
file!           file or directory (folder)
url!            URL
tag!            tag in the sense of HTML, XML etc.
email!          email-address
binary!         sequence of bytes
image!          2-dimensional array of pixels (RGBA values stored in 4 bytes each) 
bitset!         sequence of values true or false
map!            collection of pairs of values where the first value in each pair functions
                as key for retrieval of the second; keys are restricted to types in
                scalar!, all-word! and any-string!
object!         collection of word-value pairs with a context in which the words
                (also called fields) are bound, and refer to the corresponding values;
                objects are capable of triggering asynchronous events in response
                to changes in their components, thus enabling reactive programming;
                objects have a "class" property associated with them
error!          specialized objects representing error conditions
native!         pre-defined functions with built-in evaluation according to special rules
action!         pre-defined polymorphic functions of one or two arguments with built-in evaluation
op!             operators, i.e. infix functions of two arguments
function!       user-defined functions
routine!        user-defined functions with body in Red/System code
unset!          single value indicating the absence of a usable value
event!          representation of external activity   
....

=== Type categories

As seen in the previous section, Red has a rather large number of different types.
For a better understanding of their nature and that
of their values, it is useful to make a number of distinctions into different categories.

* textual representation: types having lexically/syntactically representable values or not
* internal storage: _direct types_ vs _indirect types_ and _function types_
* internal structure of values: _atomic types_ vs _composite types_
* reflectivity: types with values that admit _reflection_  or not
* evaluation: _passive types_, _decaying types_, _active types_, _function types_
* implementation of built-in functions: _parent types_

==== Types according to their textual representation

Not all types listed have lexically or syntactically determined values. Those that have not
may have their values generally be represented in programs by
expressions of the form `make <type> <spec>`, where `<type>` is a type name and `<spec>`
is a value that is interpreted by the `make` function as appropriate for the given type.
This is explained in detail in section _**Creation of values (make)**_.
_**An alternative, syntactical representation,
will be offered for a number of types (or all??) in the form of construction syntax
`#[<type> <spec>]`**_.

==== Direct/Indirect/Function types

Red values are internally stored using _value slots_ of uniform size. Values of _direct types_
fit completely into one such slot; for values of _indirect types_, which have a variable number
of _components_, the slot stores a _pointer_ to a further storage area that holds the components
of the value. As a consequence, when a word ("variable") is made to refer to a value of indirect
type or such a value is supplied as argument to a function, the components of this value may
be changed through operations on the variable or the function argument.
In order to prevent this, values of indirect types must be explicitly copied before being
transmitted as argument or having a word refer to them. The built-in function `copy` will do this.
If the components themselves are of indirect type, `copy` will not copy their components,
unless the function refinement `/deep` is used. 

A third category to be distinguished is that of _function types_, where pointers to the argument
list and the body are stored in the slot.

==== Atomic/Composite types

Values of certain types have _components_ which may be extracted and/or changed using a variety of
facilities which will be specified below under evaluation. Such types are called _composite_ 
and the others are _atomic_. All indirect types are composite, but the converse
is not true: some direct types are also composite. However, component selection
in values of direct types cannot be used to change the component, only to extract it.
Making such a component refer to a new value results in a new instance of the direct value
being created, having the changed component.

==== Types that admit reflection

Values of some types have (internal) properties of interest to the user which may usefully be exposed.
E.g. the set of words from the word/value pairs making up an object may be retrieved by the built-in
function `words-of`. Likewise, the argument spec of a function may be retrieved by `spec-of`.

_** We should perhaps consider `context?` or rather `context-of` as a reflector also**_

==== Types according to the evaluation of their values

* Values of _passive types_ evaluate to themselves. The great majority of types belong to this category.
* Values of _decaying types_ are quoted instances of other values. They evaluate to the unquoted value.
* Values of _active types_ are bound to a context, their binding can be retrieved to yield the value referred to.
* Values of _function types_, when evaluated, result in the application of the function to its arguments.

Detailed rules for the evaluation in these various cases are given in section _**Evaluation rules**_. 

==== Parent types

The notion of _parent type_ arises in the implementation of _actions_, i.e. pre-defined polymorphic
functions of up to two arguments with built-in evaluation, e.g. `add`, `subtract`, `copy`, `find`, etc.
The implementation uses a _dispatch table_ which contains a pointer to a specific run-time
function for each allowed combination of action and type of first argument. These functions
are grouped by the type to which they apply. Now for any action/type combination,
such function may be designated as _inherited_ from the parent type, and in this way
two or more types may share the same implementation for that action.

_**Mention pseudo types `symbol`, `series!` and `context!`?**_ 

==== Overview table

....
type     value representation  direct (D)/      atomic (A)/   reflection     passive (P/        parent type
            lexical (L)/       indirect (I)/    composite (C)    (R)         decaying (D)/
            syntactic (S)/     function (F)     values                       active (A)/
            using make (M)/      storage                                     function (F)
            using words (W)                                                  evaluation
                                                                   
datatype!         W                 D                A                            P   
typeset!          M                 D                A                            P   
none!             W                 D                A                            P
logic!            W                 D                A                            P
char!             L                 D                A                            P              integer!
integer!          L                 D                A                            P
float!            L                 D                A                            P
percent!          L                 D                A                            P              float!
time!             L                 D                C                            P              float!
pair!             L                 D                C                            P
tuple!            L                 D                C                            P
word!             L                 D                A             R              A
lit-word!         L                 D                A             R (#2618)      D               word!
set-word!         L                 D                A             R (#2618)      A               word!
get-word!         L                 D                A             R (#2618)      A               word!
refinement!       L                 D                A             R (#2618)      P               word!
issue!            L                 D                A             R (#2618)      P               word!
handle!           W                 D                A                            P               integer!
block!            S                 I                C                            P
hash!             M                 I                C                            P               block!
paren!            S                 I                C                            A               block!
path!             L                 I                C                           A+F              block!
lit-path!         L                 I                C                            D               path!
set-path!         L                 I                C                            A               path!
get-path!         L                 I                C                            A               path!
vector!           M                 I                C                            P               string!
string!           L                 I                C                            P
file!             L                 I                C                            P               url!
url!              L                 I                C                            P               string!
tag!              L                 I                C                            P               string!
email!            L                 I                C                            P               string!
binary!           L                 I                C                            P               string!
image!            M                 I                C                            P
bitset!           M                 I                C                            P
map!              S                 I                C             R              P
object!           M                 I                C             R              P
error!            M                 I                C             R              P(note)         object!
native!           W                 F                A             R              F
action!           W                 F                A             R              F               native!
op!              W+M                F                A             R              F               native!
function!         M                 F                A             R              F
routine!          M                 F                A             R              F               function!
unset!            M                 D                A                            P
event!            W                 D                C                            P
....
Note: `error!` values evaluate to themselves, but raise an error in addition. See _**Errors**_

=== Type hierarchy

For the convenience of the user, certain typesets have been pre-defined
which group related types. These will notably be used for indicating
the allowed types of arguments to polymorphic functions. E.g. `power` takes
two arguments whose types are both in the typeset `number!`.

....
any-type!              
|--default!              
|  |--immediate!         
|  |  |--datatype!        
|  |  |--typeset!         
|  |  |--none!            
|  |  |--logic!           
|  |  |--scalar!          
|  |  |  |--char!          
|  |  |  |--number!        
|  |  |  |  |--integer!     
|  |  |  |  |--any-float!   <---- see issue #2565
|  |  |  |     |--float!     
|  |  |  |     |--percent!   
|  |  |  |--time!          
|  |  |  |--pair!          
|  |  |  |--tuple!         
|  |  |--any-word!
|  |  |  |--word!          
|  |  |  |--lit-word!      
|  |  |  |--set-word!      
|  |  |  |--get-word!      
|  |  |--refinement!    
|  |  |--issue!         
|  |  |--handle!            
|  |--series!            
|  |  |--any-block!       
|  |  |  |--any-list!      
|  |  |  |  |--block!       
|  |  |  |  |--hash!        
|  |  |  |  |--paren!       
|  |  |  |--any-path!      
|  |  |     |--path!        
|  |  |     |--lit-path!    
|  |  |     |--set-path!    
|  |  |     |--get-path!    
|  |  |--vector!          
|  |  |--any-string!      
|  |  |  |--string!        
|  |  |  |--file!          
|  |  |  |--url!           
|  |  |  |--tag!           
|  |  |  |--email!         
|  |  |--binary!          
|  |  |--image!           
|  |--bitset!            
|  |--map!               
|  |--any-object!        
|  |  |--object!          
|  |  |--error!           
|  |--any-function!      
|     |--native!          
|     |--action!          
|     |--op!              
|     |--function!        
|     |--routine!         
|--internal!            
   |--unset!             
   |--event!             
....

=== Type and typeset related functions

The built-in function `type?` will yield the type of a value. For every pre-defined
type and typeset there is a built-in function which will test if a value is of that type
(or a type in that typeset). These functions have the name of the type(set) with the
`!` replaced by `?`.

Examples:
....
type? 1        -> integer!
integer? 1     -> true
number? 1.0    -> true
....

== Values

=== Introduction

The types whose names are mentioned in rule `S100` (`integer!` to `map!`) are the only ones
that have lexically or syntactically determined values. Values that are not lexically
or syntactically determined may generally be represented in programs with the help
of the built-in function `make`. This is one of three related means that Red provides
in order to produce new values:

* creating them with the help of other ones (built-in function `make`)
* converting values to related ones of other types (built-in function `to`)
* changing their type without changing their content (built-in function `as`)

All three built-in functions have two arguments: `<type>` and `<spec>`,
where `<type>` evaluates to a type (`datatype!` value) or to a value (_prototype_)
of the desired type and `<spec>` is interpreted as appropriate for the given type. 

For several types, the available values are referred to by words at program start: `none!` has `none`,
`logic!` has `true = yes = on` and `false = no = off`, and `datatype!` has all the valid
type names pre-defined; likewise `native! action!` and `op!` have all the built-in functions
and operators pre-defined. Values of types `event!` and `handle!`, that are used to
communicate with operating system, can only be represented by words that are arguments to functions
handling this communication.

_**Mention general typed value constructor #[ <type> <value>* ]**_

The following sub-sections will specify the lexical structure resp. the `<spec>` argument
of the `make`, `to` and `as` function for values of each of the types as appropriate.

=== Lexical structure of values

==== `integer!`

**`S101`**::
An `integer!` value is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
_**Hexadecimal notation, eg FFh, is omitted as this is under discussion**_

Examples: `123`, `-123`, `+0001`, `1'000`

==== `float!`

**`S102`**::
A `float!` value is written as a signed floating point number in the range of the IEEE 754 binary64 format,
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`.
The number may be followed by `E` or `e` with a signed integer exponent on base 10.
Note that in this case, no decimal point is required.

Examples: `1.23`, `-0.5`, `.5`, `+010.20`, `1E9`

==== `time!`

**`S103`**::
....
    <time> ::= <hmsd> | +<hmsd> | -<hmsd>
    <hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
               <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any unsigned `<integer>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

Examples: `10:20`, `10:20:30.456`, `20:30.5`, `-1:00:00`

==== `tuple!`

**`S104`**::
A `tuple!` value is written as 3 to 12 `integer!` values in the range `0..255` separated by dots `.`

Examples: `192.168.1.2` (an IPv4 address), `255.255.128` (an RGB value)

==== `word!`

**`S105`**::
A `word!` value is written as one or more characters from the entire Unicode range excluding control characters
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # $ % @ : ;`.
A `word!` value does not begin with `0-9` or `'`.
Words are _case-insensitive_, i.e. changing any letter in the word into the corresponding upper- or lower-case
variant does not create a different word.

Examples: `abc`, `Abc`, `ABC`, `+`, `<>`, `integer!`, `last-item?` ; the first three are the same `word!` value.

Note: punctuation characters from the ASCII subset that *are* allowed in words are: `! & ' * + - . < = > ? _ `` `| ~`.

==== `char!`

**`S106`**::
....
    <char> :: = #"<single-character>"
    <single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
    <escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) |
                          ^(esc) | ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
    <hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....
where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

A `char!` value must be a valid single Unicode code point, i.e. an integer in the range `0` to `10FFFFF` (hexadecimal notation). 

A `<viewable character>` is, in most cases, simply a displayable character. For example, `e`, `é`, `€` or `😀`.
When a displayable character requires two or more graphemes to display it, each grapheme requires a separate Red character.
For example, when `é` is encoded in its two character decomposed form `e` (`U+0065`) followed by
the combining `´` (`U+0301`) they cannot be considered a single `char!` value, and programs must
explicitly handle their interpretation. 

The correspondence between the escaped characters and Unicode Code Points is given in the table below.

     Named Form   Short Form    Character           Code Point
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form (the beginning of)
an `<escaped-character>` or `<hexadecimal-codepoint>`. Thus e.g. `^3` yields the same as `3`.

Examples: `#"A", #"^/", #"^(0A)"`

==== `string!`

**`S107`**::
....
     <string> ::= "<single-character>*" | {<single-character>*}
....

where `<single-character>` is defined in rule `S106`

When the `<string>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `}`
character that is part of the `<string`> must be escaped by preceding it with `^`. Within a `<string>`,
the same remark holds for `^` as noted above for a `<char>`. 

Examples: `"abc^/def", {abc` +
`def}`

==== `file!`

**`S108`**::

A `file!` value is written as `%` followed by one or more non whitespace characters, or by zero or more
characters enclosed in `"  "` in which case whitespace characters except line feed and next line may be
included. The interpretation of this value is operating system dependent, but escaped characters of the
form `%<hex>` are accepted and converted.

==== `url!`

**`S109`**::

A `url!` value is written as three or more non whitespace characters, of which at least one `:` which must not
be the first or last character. Escaped characters of the form `%<hex>` are accepted and converted.

==== `email!`

**`S110`**::

An `email!` value is written as two or more characters containing one `@` but not beginning with it.
Escaped characters of the form `%<hex>` are accepted and converted.

==== `tag!`

**`S111`**::

A `tag!` value is written as zero or more characters, not starting with `<`, `=` or `>`, enclosed in `< >`.
Characters `"` and `'` are allowed but must each be properly paired and nested.

==== `binary!`

**`S112`**::
....
    <binary> ::= 2#{<base2-byte>*} | #{<hex>*} | 16#{<hex>*} | 64#{<base64-char>*}
....

where `<base2-byte>` is a group of 8 digits `0` or `1`, `<hex>` is defined in rule `S106`
and `<base64-char>` is a single character from the set `A-Z a-z 0-9 + /`; the individual elements within
the `#{ }` brackets (`<base2-byte>`, `<hex>` or `<base64-char>`) may be separated from the
brackets and from each other by whitespace.

Examples: `2#{00000001 00000010 00000011}, \#{ 01 02 03 }, 64#{AQID}`

In order to help convert between the 3 representations (base2, base16 and base64),
the built-in functions `debase` and `enbase` have been defined. They each have
a refinement `/base` with an argument of 2, 16 or 64 (default).

Examples:
....
enbase #{010203}           -> "AQID"
enbase "^A^B^C"            -> "AQID"
enbase/base #{010203} 2    -> "000000010000001000000011"
debase "AQID"              -> #{010203}
....


==== `path!`

**`S113`**::
....
    <path> ::= <path-head>/<selector>
    <path-head> ::= <word> | <path>
    <selector> ::= <integer> | <word> | :<word> | <paren>
....

Examples: `list/1/2`, `system/view/screens/2`, `list/:i`, `list/(i)`, `copy/part`

=== Creation of values (`make`)

For some types, the values can *only* be introduced in a program as a
result of the `make` function. This section deals first of all with the types
for which that is the case, and with `map!` which has a "parallel"
syntactic form of its own. The make function can also be used
to construct values of other types. This is dealt with in the
latter part of the section.

Note that `make` evaluates its arguments. In this section, therefore,
non-terminals like `<integer>` do not stand for a literal integer
but for a value (to be evaluated) of `integer!` type etc.
Note also that, as stated above, the first argument of `make` does not
have to be a `datatype!` value; if it is a value of another type,
that type is taken to be the desired type. This is not made explicit
in the following rules, except in the case of `make object!` where
an `object!` value as second argument has a different interpretation.
In the case of `make error!` only the type `error!` is allowed as first argument
_**See issue 2640**_.

In the following rules, the sign `°` signifies an optional element.

==== `typeset!`

**`S114`**::
....
<typeset> ::= make typeset! [<typeset-element>*]
<typeset-element> ::= <typeset> | <datatype>
....

Examples: `number!` is defined as `make typeset! [integer! float! percent!]`,
`scalar!` is defined as `make typeset! [char! number! time! pair! tuple!]`.

Note that an empty typeset is allowed (`make typeset! []`).

==== `hash!`

**`S115`**::
....
<hash> ::= make hash! <block> 
....
The contents of the `<block>` are copied (not deeply).

==== `vector!`

**`S116`**::
....
<vector> ::= make vector! <vector-spec>
<vector-spec> ::= <integer> | <block> | [ <type-and-size> <block>]
<type-and-size> ::= char! 8 | char! 16 | char! 32 |
                    integer! 8 | integer! 16 | integer 32! |
                    float! 32 | float! 64 | percent! 32 | percent! 64
....
The `<integer>` should be non-negative. It produces an empty `vector!` value with the prescribed
number of components of type `integer!` and size 32 being allocated _** and set to zero **_.
The components of the `<block>` should all have the same type `char! integer! float!` or `percent!`. 
If `<type-and-size>` are omitted, type is deduced from the contents of `<block>`, and size is
the default size (32 for `char!` and `integer!`, 64 otherwise). If `<block>` is empty, the assumed type
is `integer!` of size 32.

Examples: `make vector! [], make vector! [integer! 16 [1 2 3]], make vector! [#"a" #"b" #"c"]`

==== `image!`

**`S117`**::
....
<image> ::= make image! <image-spec>
<image-spec> ::= <pair> | [<pair> <tuple>] | [<pair> <binary>] | [<pair> <binary> <binary>] 
....
If `<image-spec>` is `<pair>`, the image is created with the given dimensions, and with all pixels having color
`255.255.255` and transparency `0`. If a `<tuple>` is specified, this determines the color of all pixels,
transparency being `0`. If a single `<binary>` is specified, this should contain the array of colors of all pixels
(three bytes per pixel, stored by horizontal line), the transparency being `0`. The second `<binary>`, if present,
contains the transparency (one byte per pixel, in the same ordering).

Examples:
....
make image! 200x300, make image! [200x300 255.0.0],
make image! [2x2 #{FFFFFFCCCCCCBFBFBF0C0C0C} #{00000000}]
....

==== `bitset!`

**`S118`**::
....
<bitset> ::= make bitset! <binary> | make bitset! <bitset-spec> | charset <bitset-spec>
<bitset-spec> ::= <integer> | <char> | <string> | [<bit-position>*] | [not <bit-position>*]
<bit-position> ::= <integer> | <char> | <string> | <char> - <char> | <integer> - <integer>
....

A `<binary>` produces a `bitset!` value that is bit-by-bit equal to the `binary!` value.
The difference between `binary!` and `bitset!` is that `binary!` values have components
that are integers `0..255`, with 1-origin index, while `bitset!` values have components
that are `logic!` values (`true = 1, false = 0`), with 0-origin index.
The built-in function `charset` is defined as shorthand for `make bitset!`,
except that `<binary>` is not allowed as its argument. The `<bitset-spec>` that is
an `<integer>` produces an "empty" bitset (all bits set to false) of size the nearest
multiple of 8. In all other cases the `<bitset-spec>` provides a list of bit-position numbers,
or ranges of them, that are to be set to `true`. The `<char>` is interpreted as the Unicode Codepoint number.
A `<string>` is interpreted as the collection of all its component characters.
The length of the bitset is computed as the smallest multiple of 8 needed to fit the highest
bit number (0-origin). An "empty" bitset created by `[ ]` is 8 bits (one byte) long.
A `<bitset-spec>` that is a block starting with `not` produces the bit-by-bit complement of the bitset
produced by the following bit-position numbers, while actually storing only these bit-positions.

Examples: `make bitset! 16, charset "abc", charset [#"A" - #"Z" #"a" - #"z"]`

The built-in function `complement?` will test if the bitset is a complemented one,
i.e. if its complement is what is actually stored.

==== `object!`

**`S119`**::
....
<object> ::= make object! <object-spec> | object <object-spec> | context <object-spec> |
             make <value> <object-spec>
<object-spec> ::= <block>
....

The built-in functions `object` and `context` are defined as shorthand for `make object!`.
The `<value>` must be a value of type `object!`.

If the first argument to `make` is `object!` this creates a new object as follows.
A new context is created and associated to the object. The words of the new context
(i.e. the fields of the object) are the words of all the `set-word!` values that are
(first-level) components of the `<object-spec>`. The corresponding values are set
to the unset value. The `<object-spec>` is bound to this context (see section
_**Built-in bind function**_). The bound block is then _executed_.
The `class` property of the newly created object is set to a unique integer.

If the first argument to `make` is an `object!` value, it serves as _prototype_.
A new object is created whose associated context is a copy of the prototype's context.
The `set-word!` values that are (first-level) components of the `<object-spec>`
are added to this context if they are not already present in that context.
The `<object-spec>` is then treated as in the previous case.
The `class` property of the new object is copied from the prototype.
The new object is said to be _derived_ from the prototype.

An additional built-in function `construct` _** does what?? **_

The built-in function `extend` takes an `object!` value as first argument
and a set of key-value pairs as second argument of type `block! hash!` or `map!`.
It will add the keys that are not present in the map, with their values,
and replace the values for those keys that are
already present. The keys and values are not evaluated.
_**It is not yet implemented**_

==== `error!`

**`S120`**::
....
<error> ::= make error! <error-spec>
<error-spec> ::= <integer> | <block> | <string>
....

For the fields of an `error!` value, and the structure of the error repertoire
(`system/catalog/errors`) see section _**Errors**_.

If the `<error-spec>` is an `integer!` value, it is used to find values for the `type`
and `id` fields of the `error!` value which result in the `code` with that `integer!`
value. The values of these two fields are then bound as described in section _**Errors**_.

If the `<error-spec>` is a `block!` value, it should either contain two `word!` values
which will be used for the `type` and `id` value of the intended `error!` value, or
it should be an `<object-spec>` containing at least `type:` and `id:` fields;
in the former case, the `type` and `id` values will be bound as described in section _**Errors**_;
in the latter case, the `<block>` will be treated as described under rule `S119`;
note that also in this case, the `<block>` will be executed.

Except in the case where an `<object-spec>` is provided, any fields other than `type` and `id`
cannot be set by `make`. They should be set afterwards.

If the `<error-spec>` is a `string!` value, this will be used as `arg1` for the error with
`type: 'user id: 'message`. 

Note that `error!` values all have `class = 0`.

==== `function!`

**`S121`**::
....
<function> ::= make function! [<function-spec> <function-body>] | func <function-spec> <function-body> |
               has [<argument>*] <function-body> | does <function-body> | function <function-spec> <function-body>
<function-spec> ::= [<docstring>° <argument-spec> <return-spec>°]
<docstring> ::= <string>
<argument-spec> ::= <argument>* <optional-argument>*
<argument> ::= <argument-name> <argument-doc>° | <argument-name> [<typeset-element>*] <argument-doc>°
<argument-name> ::= <word> | '<word> | :<word>
<argument-doc> ::= <string>
<optional-argument> ::= <refinement> <argument-doc>° <argument>*
<refinement> ::= /<word>
<return-spec> ::= return: [<typeset-element>*]
<function-body> ::= <block>
....
For `<typeset-element>` see rule `S114`.

The `<docstring>` may be used to document the purpose and working of the function. Each `<argument-doc>`
may be used to document the purpose and usage of the associated  `<argument>`. When present, the type(set)s
of each `<argument>` will be used to check the type of the actual argument supplied.
Likewise, when present, the type(set)s of the `<return-spec>` will be used to check the type of the result.
_**This is not yet implemented!**_
The optional argument `/local` is conventionally used to list the local words of the function.
It is normally put after any other optional arguments (in fact the built-in `help` function
expects this to be the case).

The built-in function `func` is defined as shorthand for `make function!`. The built-in function
`has` is defined as shorthand for a function without other arguments than local words, thus
`has [<arguments>] <block>` is equivalent to `func [/local <arguments>] <block>`.
The built-in function `does` is defined as shorthand for `func [ ]` (no arguments at all).
The built-in function `function` is similar to `func` but it adds all set-words
found in the body to the list of local arguments.

==== `routine!`

**`S122`**::

....
<routine> ::= make routine! [<routine-spec> <routine-body>] | routine <routine-spec> <routine-body>
<routine-spec> ::= [<docstring>° <routine-argument>* <locals>° <routine-return>°]
<routine-argument> ::= <word> <argument-doc>° | <word> [<type>] <argument-doc>°
<locals> ::= /local <routine-argument>*
<routine-return> ::= return: [<type>]
<routine-body> ::= <block>
....
For `<docstring>` and `<argument-doc>` see rule `S121`. Note that routines
do not have optional arguments, except `/local`. Note also that arguments
and return spec must have a single type specified.

The built-in function `routine` is defined as shorthand for `make routine!`.

Values of type `routine!` may not occur in programs submitted to the interpreter.
When compiling, the toolchain will convert the routine into a Red/System function as follows:
the `<routine-spec>` is converted into a Red/System function specification block
by changing every Red type mentioned in it, except `integer! logic!` and `float!`
to the corresponding Red/System `struct!` alias that describes the value slot,
thus `string!` becomes `red-string!` etc.; an argument without a type is given
Red/System alias `red-value!` which corresponds to `any-type!`; the `<routine-body>`
(which lexically consists of Red values) becomes the body of this Red/System function,
and will be treated as Red/System code. The function thus constructed becomes part
of the intermediate Red/System code that the toolchain produces internally
for compilation into machine code.

The construction of routines requires a fairly deep knowledge of the Red runtime system
and the representation and storage of argument and result values.

==== `op!`

**`S123`**::
....
<op> ::= make op! <function> 
....

In contrast to `action!` and `native!` values which cannot be made by means of
`make`, the user may create new infix functions of two arguments (operators),
using `make op!`. The `<function>` should have exactly two arguments and no optional
arguments.

Example: `&&: make op! func [a b][all [a b]]`.

==== `map!`

A `map!` value can be produced both as grouped value and by `make`. The specification
is the same in both cases.

**`S124`**::
....
<map> ::= #(<map-spec>) | make map! [<map-spec>]
<map-spec> ::= <key-value-pair>*
<key-value-pair> ::= <key><value>
....

Each `<key>` should be a value of a type in `scalar!, any-word!` or `any-string!`.
All keys should be unique. If identical keys are encountered in the `<map-spec>` the value
corresponding to the last one encountered is taken. Keys of any type within `any-word!`
that do not differ in their symbol are considered identical for this purpose.

Note that values of `logic!` and `none!` type are not allowed as keys. Nevertheless
`true false` and `none` may occur in `<key>` position. Since the constituents
of `<map-spec>` are not evaluated, these words will be treated as `word!` values.
The same is true if they occur in `<value>` position.

The built-in function `extend` takes a `map!` value as first argument
and a set of key-value pairs as second argument of type `block! hash!` or `map!`.
It will add the keys that are not present in the map, with their values,
and replace the values for those keys that are already present.
The keys and values are not evaluated.

==== other types 

* Making `integer!` and `float!` values from `logic!` values: `true -> 1/1.0, false -> 0/0.0` _**See issue 2644**_
* Making `logic!` values from `integer!` and `float!` values: `0/0.0 -> false, all else -> true`
* Making `time!` values from `block!` values: the block should contain three values (hours, minutes, seconds).
* Making a `series!` value from an `integer!` or `float!` value: the `float!` value is truncated; the integer
or truncated number is used to create an empty `series!` value with storage for the given number of components reserved.
This does not apply to `image!` values.

=== Conversion of values (`to`)

Conversion is possible for selected combinations of _source_ and _target_ type.
The list given below is meant to be exhaustive. A summary table is available
elsewhere (see section _**Additional documentation**_).

Note that for each type that may occur as target type, there is a built-in function
defined as shorthand: `to-integer <spec>` for `to integer! <spec>` etc.

==== Target types `none!` and `unset!`

The functions `to-none` and `to-unset` yield a `none!` resp. `unset!` value
for any argument value.

==== Target type `logic!`

The function `to-logic` yields `true` for any argument value except `none`. Note that
`to logic! 0` yields `true` whereas `make logic! 0` yields `false`! _**See issue #2645**_

==== Target types in `any-string!`

The function `to-string` yields the same result as the built-in function `form` (see
section _**Conversion from/to textual representation**_) except for

* `none!` values: conversion is not allowed
* `binary!` values: these will be decoded as UTF-8
* `any-list!` values: the function will apply `form` to each component and concatenate the results

The functions `to-file` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target types in `any-list!`

The function `to-block` yields a block with the argument as single component except
for

* `string!` values: first applies `load` (see section _**Conversion from/to textual representation**_)
and applies `to-block` to the result
* `typeset!` values: yields a block with the individual types
* `any-block!` and `vector!` values: yields a block with the components
* `any-object!` and `map!` values: yields the same as `body-of`

The functions `to-paren` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target type `integer!`

The function `to-integer` is defined for

* `any-float!` and `time!` values: truncates the floating point value (seconds in the case
of `time!`) towards `0`
* `char!` values: yields the Unicode Code Point number
* `binary!` values: interprets the first 4 bytes as an integer (two's complement notation)
if there are fewer than 4 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error

==== Target types in `any-float!` and `time!`

The function `to-float` is defined for

* `integer!` values: yields the corresponding `float!` value
* `time!` values: yields the number of seconds
* `char!` values: yields the Unicode Code Point number as `float!` value
* `binary!` values: interprets the first 8 bytes as a floating point number (IEEE 754 binary64 format)
if there are fewer than 8 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain two components of type `integer!` or `float!`
the result is the first number times 10 to the power of the truncated second number

The function `to-percent` will perform the same conversions and yield a value of type `percent!.
The function `to-time` will do the same (except that a `block!` argument is not allowed)
and yield a `time!` value.

==== Target type `char!`

The function `to-char` is defined for

* `number!` values: yields the Unicode Code Point with the (truncated) number
* `binary!` values: assumes UTF-8 encoding; decodes as many bytes as necessary to obtain a Unicode Code Point
* `any-string!` values: yields the first character

==== Target type `pair!`

The function to-pair is defined for

* `integer!` and `any-float!` values: yields the pair with two components equal to the (truncated) number
* `any-list!` values: these should contain two `integer!` or `float!` values;
yields the pair wih the (truncated) numbers as components

Note that a similar built-in function `as-pair` of two arguments is defined,
which creates a pair out of the arguments.

==== Target type `tuple!`

The function to-tuple is defined for

* `binary!` values: yields the first 12 bytes or fewer as tuple components; if only 1 or 2 bytes are 
present, components `0` are added
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain only `integer!` or `float!` values in the range `0..255`;
yields the first 12 components or fewer as tuple components;  if only 1 or 2 values are 
present, components `0` are added

==== Target type `binary!`

The function `to-binary` is defined for

* `integer!` and `any-float!` values: yields the corresponding 4 resp. 8 byte binary value
* `char!` values: yields the 1 to 4 byte binary value corresponding to the Unicode Code Point number
* `tuple!` values: yields the 3 to 12 bytes binary value corresponding to the tuple components
* `bitset!` values: yields the corresponding binary value
* `string!` values: yields the UTF-8 encoded binary value
* `any-list!` values: these should contain only `integer!` or `float!` values;
the binary equivalents are concatenated, using as few bytes as needed
for each `integer!` value and 8 bytes for each `float! value
* `image!` values: yields a binary value with 4 bytes for each pixel

==== Target types in `any-word!` `refinement!` and `issue!`

The function `to-word` is defined for:

* `char!` values: makes a `word!` value with that single character
* `logic!` and `datatype!` values: yields the word that refers to the value
* `string!` values: yields the result of `load` or an error

The functions `to-lit-word` etc. perform the same conversiosn and yield
the result as a value of the appropriate type.

Note that `to-word none` does not yield the word `none`, it raises an error.

==== Target type `image!`

The function `to-image` is defined for `object!` values that are _faces_ i.e.
derived from the `face!` object which describes a window in the Red GUI system.
It yields the face such as it would be rendered on the screen, as an `image!`
value. See further the documentation of the GUI system (reference in section
_**Additional documentation**_).

==== Additional conversion functions

* `as-pair` takes two integer arguments and combines them into a `pair!` value,
thus `as-pair x y` is equivalent to `to-pair reduce [x y]` 
* `as-color` takes three integer arguments `0..255` and makes a `tuple!` value
representing a color (RGB)
* `as-rgba` does the same with four arguments, with additional transparency (RGBA)
* `as-ipv4` also has four arguments, and suggests an IPv4 address interpretation of the tuple
* `uppercase` and `lowercase` will work on values of type `char!` and `any-string!`
and convert them to upper case or lower case respectively; they use the
Unicode 7.0 case folding table (only character pairs with status C and S)

=== Casting of values (`as`)

The casting facility applies to most of the `series!` types, and makes use of the fact
that values of several different but related types have their component values
stored in identical fashion. Therefore a change of type can be performed without copying
any component values. Two groups of related types are involved: `block! paren! any-path`
on the one hand, and `any-string!` on the other. The type of the second argument shoul
d be in the same group as the (type of the) first argument. The result is a new value
of the desired type, pointing to the components of the old value.
Note the absence of `hash!` from the first group, explained by the fact that `hash!`
values are stored differently from other `any-block!` values.

=== Components of values

Composite values can have their components extracted and changed by various means.

==== Indexing

Values that are sequences (with types in `series!` and `bitset!`)
admit indexing by integers, and images also by pairs as coordinates.
The lexical/syntactic form for this is `<path>` for extraction and `<path>: <value>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value to be indexed and `i` is the index, then `v/i` is equivalent to `pick v i`
and `v/i: x` is equivalent to `poke v i x`. Note that for lexical reasons, a `pair!` value as index
must be enclosed in parentheses, thus if `v` is an image, the pixel at 2x2 is addressed as `v/(2x2)`.
Note that `pick` and `poke` additionally allow the `logic!` values `true` and `false` as indexes:
`true ~ 1` and `false ~ 2`.

Values of type `time! pair!` and `tuple!` also admit component selection
by "indexing". In the case of `time!` values, which are stored as a `float!` number
of seconds, this selection proceeds by calculation (`1 ~ hour`, `2 ~ minute`, `3 ~ second`).
For `pair!` , `1 ~ x` (horizontal dimension, left to right) and `2 ~ y` (vertical dimension,
top to bottom). As stated in section _**Atomic/Composite types**_,
component selection in values of direct types cannot be used to change the component, only to extract it.
That is, only `<path>` and `pick` are allowed for these values.

The built-in functions `first second third fourth` and `fifth` are defined as `pick <value> 1` etc.

==== Selection by "key"

This is possible both for values that are sequences (with types in `series!`,
but not `bitset!`) and for values of types `object! error!` and `map!`.
The lexical/syntactic form for this is again `<path>` for extraction and `<path>: <value>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value from which to select and `k` is the key, then `v/k` is equivalent to `select v k`
and `v/k: x` is equivalent to `put v k x`.

The semantics of selection are different in the two cases (sequences vs. objects/maps).
For sequences, a `find` action is performed on the components using the key,
which should be a single value of the right type, or itself a sequence of such values,
and the first position where the key is found is marked. The result is then
the component *after* the found key (single or sequence). For the other types,
which contain key/value pairs, the result is the value corresponding to the given key.
In the case of `object!` and `error!` it is customary to call the keys _fields_.

Values of type `time! pair! email!` and `image!` also admit component selection
by specific words, and values of type `event!` have this as the only way of selection.
Again, for the direct types among them, only the `<path>` and `pick` forms are valid.

In case of `time! email! image!` and `event!`, the result is obtained by performing
a certain calculation.

* `time!` values: given a `float!` number of seconds, the `hour` and `minute` components
are the result of finding the whole number of `3600` seconds in the total, and then the
whole number of `60` seconds in the remainder; the `second` component is what remains after that
* `email!` values: the `user` component is the part before the `@` and the `host` component
is the part after the `@`
* `image!` values: the `size` component is the `pair!` value that holds the dimensions,
the `argb`, `rgb` and `alpha` components are the `binary!` sequences of RGBA, RGB and A values
respectively
* `event!` values: the components, which are explained in the Red GUi documentation
(see _**Additional documentation**_) are calculated in an OS-dependent way

==== Overview table

....
type         indexed      built-in    key values or types                built-in
             components   functions                                      functions

time!        1 2 3        pick        hour minute second                 --
pair!        1 2          pick        x y                                --
tuple!       1 .. 12      pick        --                                 --
any-block!   integer!     pick poke   any-type!                          select put
vector!      integer!     pick poke   integer! char!                     select (put see issue #1960)
any-string!  integer!     pick poke   char! any-string! binary!          select (put see issue #1960)
+ email!                              host user                          --
binary!      integer!     pick poke   integer! char! any-string! binary! select (put see issue #1960)
image!       integer!     pick poke   size rgb alpha argb                --
             pair!        pick poke
bitset!      integer!     pick poke   --                                 --
map!                                  scalar! all-word! any-string!      select put
object!                               word!                              select put
error!                                code type id arg1 arg2 arg3        select
                                           near where stack
event!                                type face window offset key        --
                                           picked flags away?
                                           down? mid-down? alt-down?
                                           ctrl? shift?
....

=== Reflection on values

Values of some types have (internal) properties of interest to the user which may
usefully be exposed.

This concerns first of all `(any-)word!` values for which information on their
binding may be obtained by means of two built-in functions: `context?` and `index?`.
These are explained in section _**Contexts**_. _**See issue #2618**_. 

_**What about `owner`??**_

The function `complement?` is described in section _**bitset! in Creating values**_.

The function `face?` tests if an object is derived of the `face!` object which is
explained in section _**GUI System**_.

_**Functions on vector! values have been requested see issue #2527**_

For values of type `object! error!` and `map!`, which consist of key/value pairs,
the collection of keys, that of values, and the set of key/value pairs may each
be obtained as a block by means of the built-in functions `words-of values-of`
and `body-of`. For convenience, `keys-of` is defined as synonym for `words-of`.
In addition, for objects there is the property `class-of` which yields
a unique number which is given to each object that is created from a `<spec>`, and is
inherited by objects derived from it (see _**Values of map! type**_).

For `any-function!` values, one can obtain the full `<argument-spec>` through
the built-in function `spec-of` and the list of formal argument names through
the function `words-of` _**not yet implemented**_. For `function!` and `routine!` values, there is in
addition the function `body-of` which yields the function/routine body.

All functions `<property>-of <value>` are shorthand for the general function
`reflect <value> <property>` e.g. `words-of <value>` is defined as `reflect <value> 'words`. 

Note that the `help` built-in function is typically making good use of `spec-of`. 

=== Comparison of values

Red has the following operators and corresponding `native!` functions
for comparison of two values. Each of these operators/functions allows
arguments of any type, although in most cases the comparison may only
yield `true` if the two types are the same. Exceptions will be noted below.
The _equality_ functions, i.e. the first four, are defined for all types
of the first argument. The others (the _ordering_ ones) are only defined
for certain combinations of types. Also this will be noted.

....
    operator   native function

    =          equal?
    ==         strict-equal?
    =?         same?
    <>         not-equal?

    <          lesser?
    <=         lesser-or-equal?
    >          greater?
    >=         greater-or-equal?
....

==== Equality comparisons

The strictest equality test is `same?` which yields true only if the values
are of the same type and the two _value slots_ (see _**Direct/Indirect/Function types**_)
have identical content. For values of direct types this comes down to simple equality,
but for values of other types it is quite possible to be equal but not the same
(e.g. two strings of identical content, but one a string literal and the
other the result of decoding a `binary!` value).

For two values to succeed the `strict-equal?` test, they have to be of the same
type and also have exactly the same value, i.e. not have the differences allowed
for the `equal?` test.

The `equal?` test ignores case differences in the spelling of words, characters
and strings, and in the case of floating point numbers, a very small difference
(1 in 10^16^) in actual value.

For values of `any-block!` type, the `strict-equal?` and `equal?` tests apply pairwise
to the components. For `any-object!` the requirements are identity of field names
and (strict) equality of field values. If the components or field values are also of
`any-block!` or `any-object!` type, there is recursion involved, with cycle detection.
For values of `vector!` type, these tests also apply pairwise to the components. In
addition, the component type (`char! integer! float!` or `percent!`) must be the same.


In all cases, for the `equal?` test, the requirement of equal type is relaxed for several
combinations of types. Within each such combination, `equal?` will allow any two types
for the values to be compared:

* `char!` and `integer!` _**See issue #2650**_
* `integer! float!` and `percent!`
* `any-word!` and `refinement!` (note the absence of `issue!`)
* `any-string!`
* `any-object!` _**See issue #2657**_

==== Ordering comparisons

The following cases can be distinguished: 

* straightforward numerical ordering: `char! integer! float! percent!` and `time!`
* lexicographic ordering (case sensitive): `pair! tuple! any-word! refinement! issue!
vector! any-string! binary!` and `bitset!`
* lexicographic ordering (with recursion and cycle detection): `any-block!` and `object!`
* no comparison: `datatype! typeset! none! logic! image! map! error! function! routine!
action! native! op! handle! event!` and `unset!`.

As a rule, for ordering comparisons the types of the two values have to be the same. However,
as with equality, for some combinations of types this requirement is relaxed.

* `char!` and `integer!`
* `integer! float!` and `percent!`
* `any-word!` and `refinement!`
* `any-string!`

For `vector!` values, the component type (`char! integer! float!` or `percent!`) must be the same.

== Words, contexts and binding

=== Words

Red uses _words_ (values of type `word!`) to access values in much the same
way that other languages use variables. However, in Red, words do not
"store" values. Rather, a word _refers to a value_ in some _context_. i.e.
evaluating the word in that context yields the value. The word is said to be
_bound to_, or _in_ the context. Since functions, 
including built-in functions and operators, are also values in Red, the words
that refer to these values appear to work like keywords in other languages.

Thus all `word!` values have two important properties in this regard: their
symbol, that is their spelling (disregarding case), and the context they are
bound to. Something words *do not* have is a restriction on what values they
can refer to. In Red, values are strongly typed, but words, when used like
variables or keywords, are not.

For practical purposes, words are internally represented by three items:
a pointer to a context, an index in a symbol table which contains the symbol, 
and an index in the context which facilitates retrieving the value the
word refers to. Each occurrence of a word carries these three items
individually, and each occurence of a word with the same symbol can
therefore be bound to a different context, and refer to a different value.
Values of types `lit-word! set-word!` and `get-word!` (these types form
typeset `any-word!` with `word!`) have the same binding as the word
with the same symbol. Variables of types `refinement!` and `issue!`,
although not bindable, may share the same symbol.

=== Contexts

A _context_ in Red is a collection of word/value pairs. The words in
this collection are all different, and the values are the values the words
refer to. One can think of it as a table composed of two columns,
where the first is a list of unique symbols and the second contains
a corresponding value for each. Each word that is bound in this context
has its symbol and the value it refers to, positioned in a row of the
table. The value can be retrieved by finding the symbol, or by using
an index (row number) in the table. Note that such tables actually exist
in the implementation as values of an internal pseudo-type.

There is one _global context_ containing all words that have passed lexical
analysis as well as those that have been pre-defined in the toolchain, and
which refer to values such as built-in functions and constants. Words in the
global context that are not pre-defined, are considered "unset", which is a
special kind of value, distinct from `none`.

In addition to the global context, any number of contexts may exist during
program execution. Every _object_ (value of type `object!`) gives rise to a
context, containing the field-name/value pairs of the object. From an
implementation viewpoint, an object is just a combination of a context
and a class. Every _error_ (value of type `error!`) is a specialized object,
and therefore also has a context associated with it. Every function 
(value of type `function!`) also gives rise to a context, which contains
the pairs of formal argument name and actual argument value to be used by 
the body of the function when it is executed.

The user may access the context of a word reflectively through the built-in
function `context?` which can be applied to any word and will yield the
context the word is bound to. Since contexts themselves are not values
of a type of the langauge, they are yielded in the form of an object or function
as the case may be. The context of a word which is a field of an error value
is yielded as an object having the same field names and values as the error.
The global context is yielded as the object `system/words`. The index of a word
in its context may be obtained through the built-in function `index?`.

=== Binding

Words are bound to contexts as a result of:

* lexical analysis
- notably when the program containing the words is submitted to the toolchain
- or when a string representing some values, including words, is submitted to the REPL
- or through application of the built-in `load` function
* applying the built-in `set` function
* evaluating a `set-word!` value
* evaluating a `make object! <spec>` construct
* applying a function to its arguments
* applying the built-in `bind` function
* applying the built-in `in` function

Details of the binding process in these cases are given in the following sub-sections.

Note that a word bound to a context does not necessarily have a value. The built-in
function `value?` tests if it does.

==== Lexical analysis

Every lexeme that is recognized in the source text as being of a type in `any-word!
refinement!` and `issue!`, either by the operation of the toolchain or
-- at runtime -- by the `load` function, is bound to the global context,
and will initially not refer to any value in that context.

==== Setting words to values

The evaluation of `<word>: <value>` is treated in rule `E105`.
Equivalent to this is the application of the built-in function `set`:
`<word>: <value>` ~ `set '<word> <value>`.

The counterpart to `set` is `unset`: this will make the word argument
refer to the unset value.

==== Object creation

This is treated in rule `S119`.

==== Function application

This is treated in rule `E110`.

==== Built-in `bind` function

The built-in function `bind` has two arguments: a word (or block of words)
and a context.

The function will try to change the binding of a single word or
of all words in a block, and will return the (modified) word or block.
It operates on values of type `word! lit-word! set-word!` and `get-word!`
(for brevity, called "words" in the rest of this section),
and will treat them at any depth within the block and its sub-blocks
(including values of type `paren! path! lit-path! set-path! get-path!` and `hash!`).

For each word to be treated it will search for the presence of an equally spelled
word in the given context, which is supplied in the form of a word
(whose context will be used), or of an object or error value or a function.
If an equally spelled word is found, the function will change the context
of the treated word to that given context and will adapt the index of the word;
otherwise, the word is left untouched.

With the `/copy` refinement the `block!` argument will be deep-copied before it
is modified.

A major application of this function is the binding of the formal arguments
of a function, as they occur within the function body, to the context which
contains the actual argument values. See evaluation rule `E110`.

==== Built-in `in` function

The built-in function `in` has two arguments: an `object!` or `error!` value
and a word.

It will bind the word to the object or error context, and yield the word thus
bound as result.

== Evaluation rules

General remark: operator application has precedence over application of other functions
and over set-word target evaluation. Note that in Red all operators (values of type `op!`)
are binary infix functions. See further rule `E112`.

The operation of the toolchain will result in the evaluation of the Red source text presented
to it. The user can, at runtime, achieve evaluation of a (fragment of) Red source, i.e. Red data,
by invoking the built-in function `do`. If this is presented with a string argument. it will
invoke `load` (see _**Input/output**_) first, and then evaluate the result. If the argument is
a block, the block will be _executed_ as described in rule `E100`.

=== Passive types

**`E100`**:: For all values of passive types evaluation yields the value itself.
This is called the **identity rule**.

Note that `block!` is one of the passive types. Thus evaluation of a block
leaves the block unchanged. The term _execution of a block_ will be used to
indicate sequential evaluation of the components of the block; the result of this
execution is the result of the last evaluation, if any, and the unset value otherwise.
See also the section _**Blocks: Reduction and selective evaluation**_.

=== Decaying types

These are `lit-word!` and `lit-path!`.

**`E101`**:: Evaluating a `'<word>` results in its `<word>` counterpart.

**`E102`**:: Evaluating a `'<path>` results in its `<path>` counterpart.

The built-in function `quote` will yield its argument, which may be of any type,
without evaluating it. In particular `quote <word>` is equivalent to `'<word>`,
and `quote <path>` is equivalent to `'<path>`.

=== Active types

==== `word!` type

**`E103`**:: Evaluating a `<word>` proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` raise an error and yield the unset value as result.
.. If the type is `error!` raise the error and yield the error value as result.
.. If the type is in `any-function!` apply the function (see rules `E110-114`).
.. Otherwise, the result is the value referred to.

Note: there are cases in which a `<word>` is not to be evaluated, e.g. when it occurs as
`<key>` or `<value>` in a `<map-spec>`, or when it is an actual argument to a function
where the formal argument is a `lit-word!`. In these cases, the predefined words `true false`
and `none` as well as the type names will be interpreted as `word!` values rather than as
`logic!` or `none!` values. To represent values of the desired type in such cases one may use
the generalized value construction syntax: `#[true], #[false], #[none]` etc.

The built-in function `get` evaluates its `word!` argument: `get '<word>` is equivalent
to `<word>`.

==== `get-word!` type

**`E104`**:: Evaluating a `:<word>` proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` yield the unset value as result.
.. If the type is `error!` (raise the error and) yield the error value as result._**see issue 2621**_
.. Otherwise, the result is the value referred to.

Note that the difference with evaluating a `<word>` is that no errors are raised
and that a function value is not applied but is itself yielded as result.

The built-in function `get` has a refinement `/any` which will ensure that
no error occurs if the `<word>` refers to the unset value. Thus `get/any '<word>`
is equivalent to `:<word>`.

==== `set-word!` type

**`E105`**:: Evaluating a `<word>:` outside an `<object-spec>` or a `<map-spec>`
has the effect that the `<word>` in its context
is made to refer to the value obtained by evaluating the next value(s). An error occurs
if no value is following or if the value obtained is unset. The result of the evaluation
is the value obtained. As a consequence, set-words may be "chained", thus: `a: b: c: 1`
is equivalent to `a: 1 b: 1 c: 1`.

As stated before, the equivalent to `<word>: <value>` is `set '<word> <value>`.
The built-in function `set` has a refinement `/any` which will ensure that
no error occurs if the <value> is unset.

==== `paren!` type

**`E106`**:: The evaluation of a `<paren>` proceeds by the evaluation of its component
values. The result is the value obtained from the last evaluation. This is similar to the
execution of a block. The following table compares parens and blocks.
....
expression          result of evaluation    comment
[1 + 2 3 + 4]         [1 + 2 3 + 4]         block! is passive type
do [1 + 2 3 + 4]      7                     do forces execution
(1 + 2 3 + 4)         7                     paren! is active type
quote (1 + 2 3 + 4)   (1 + 2 3 + 4)         quote inhibits evaluation
....

==== `path!` type

Recall the structure of `path!` values:

**`(S113)`**::
....
    <path> ::= <path-head>/<selector>
    <path-head> ::= <word> | <path>
    <selector> ::= <integer> | <word> | :<word> | <paren>
....

**`E107`**::

The evaluation of a `<path>` proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. Determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue 2578**_
.. If the result is a value of `any-function!` type, each following
`<selector>`, if any, should be an actual refinement of the function, i.e a `word!` value,
corresponding to one `<refinement>` present in the `<argument-spec>` of the function.
Evaluate the combination of the result and the actual refinements according
to the rules for values of function types (see section _**Function types**_).
.. If the result is of any other type, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the result is the component at the index given
by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
the result is obtained as in step iv hereafter. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
indirect type (except `image!`), an intermediate result is obtained by
applying the built-in function `select`
with as arguments the evaluated `<path-head>` and `<selector>`.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
direct type, `image!` or `event!`, an intermediate result is obtained as explained
in section _**Selection by "key"**_.
.. If a further `<selector>` is present, use the result just obtained as 
evaluated `<path-head>` and go to step 2, otherwise finish:
the result of the evaluation is obtained.

==== `get-path!` type

See also rule `E107`.

**`E108`**::
The evaluation of a `:<path>` value proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. Determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue 2578**_
.. If the result is a value of `any-function!` type, no following
`<selector>` is allowed and the result is the function value.
.. If the result is of any other type, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the result is the component at the index given
by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
the result is obtained as in step iv hereafter. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
indirect type (except `image!`), an intermediate result is obtained by
applying the built-in function `select`
with as arguments the evaluated `<path-head>` and `<selector>`.
.. If the `<selector>` is a `<word>`, and the evaluated `<path-head>` is of
direct type, `image!` or `event!`, an intermediate result is obtained as explained
in section _**Selection by "key"**_.
.. If a further `<selector>` is present, use the result just obtained as 
evaluated `<path-head>` and go to step 2, otherwise finish and use
the intermediate result of the evaluation.

==== `set-path!` type

**`E109`**::
TBD

=== Function types

Values of `any-function!` type must be evaluated together with any
actual refinements (`word!` values that are found as `<selector>` in a `path!`
value whose `<path-head>` evaluates to the `any-function!` value). 

Recall the basic structure of the `<argument-spec>`, which is valid, with
soem limitations,  for all values of `any-function!` type:

**`(S121)`**::
....
<argument-spec> ::= <argument>* <optional-argument>*
<argument> ::= <argument-name> | <argument-name> [<typeset-element>*]
<argument-name> ::= <word> | '<word> | :<word>
<optional-argument> ::= <refinement> <argument>*
<refinement> ::= /<word>
....

==== `function!` type

**`E110`**::

The evaluation of a `function!` value (also called _function call_
or _function application_) proceeds as follows:

. If the function does not have any arguments (optional or not), execute
the body of the function to yield the result of the function.
. If the function has any arguments (optional or not), create a context specific
to this function value, with all the words (including values of type
`lit-word! get-word!` and `refinement!`) occurring in the `<argument-spec>`.
Make all these words initially refer to `none`.
.. Evaluate as many subsequent values as needed to obtain values corresponding
to the non-optional arguments, except that when the `<argument-name>`
is a `'<word>`, do not evaluate the corresponding value, and if the
`<argument-name>` is a `:<word>`, _**then do what??**_.
Make the `<word>` of each `<argument name>` refer to the corresponding value.
.. If actual refinements are present, match each of them with the corresponding `<refinement>`
in the `<argument-spec>`. Make the `<word>` of the `<refinement>` refer to `true`.
Furthermore, process each `<argument>` following the `<refinement>`
as in the previous sub-step, evaluating the necessary lexemes and inserting the values obtained in the context.
.. Bind the body of the function to the context (see section _**Built-in bind function**_).
.. Execute the body of the function to yield the result of the function.

Note that the order of the values to be supplied for the optional arguments is dictated
by the order of the actual refinements present, *not* by the order of the `<refinement>` s
in the `<argument-spec>`.

==== `action!` type

**`E111`**::
TBD

==== `op!` type

**`E112`**::
TBD

==== `native!` type

**`E113`**::
TBD

==== `routine!` type

**`E114`**::
TBD

=== Blocks: reduction and selective evaluation

As stated before, evaluation of a block leaves it unchanged. _Execution of a block_
is the term used to indicate sequential evaluation of the components of the block,
yielding as a result the result of the last evaluation, if any, and the unset value
otherwise. Two built-in functions are available to evaluate components of a block
and preserve the results in a block.

The built-in function `reduce` applied to a block yields a new block, with
as components all the results of evaluating the block's components, in the same order.

Example:
....
reduce [1 + 2 3 + 4]        ->  [3 7]   ; reduction
do [1 + 2 3 + 4]            ->  7       ; compare with execution
....

It is also possible to selectively evaluate the block's components: the built-in function
`compose` will only evaluate those components that are of type `paren!`. With refinement
`/deep`,`compose` will also act on nested blocks. With refinement `/only`, `compose` will
evaluate a block as a block, instead of yielding its components separately.

Example:
....
compose [1 + 2 (3 + 4)]          ->  [1 + 2 7]     ; evaluation only within parens
compose [[(1 + 2)] (3 + 4)]      ->  [[(1 + 2)] 7] ; inner blocks are untouched
compose [([1 + 2]) (3 + 4)]      ->  [1 + 2 7]     ; evaluation of a block yields the components 
compose/only [([1 + 2]) (3 + 4)] ->  [[1 + 2] 7]   ; with /only, a block stays a block
compose/deep [[(1 + 2)] (3 + 4)] ->  [[3] 7]       ; with /deep, inner parens are also evaluated
....

The built-in function `collect` will execute the block which is its argument
and yield a new block as result which contains all values that are argument
to the function `keep` invoked inside the argument block.

Example:
....
collect [repeat i 10 [if even? i [keep i ** 2]]] -> [4 16 36 64 100]
....

The _shortcut evaluation_ functions `any` and `all` have a block as argument;
they will evaluate the components one by one; `any` will stop at the first
one which is not `false` or `none` and yield that as result;
if there is no such component it will yield `none`;
`all` will stop at the first one which is `false` or `none`
and yield `none` as a result; if there is no such one
it will yield the result of evaluating the last one. Note that `any [ ]`
and `all [ ]` both yield `none`.

== Numerical and logical computation

=== Basic arithmetic operations

Red makes available the usual _arithmetic operations_ through `+ - * /` as operators
(values of type `op!`) and their prefix counterparts: `add subtract multiply divide`.
In addition, there are operators and prefix functions for exponentiation (`**` or `power`),
modulo (`//` or `modulo`) and remainder (`%` or `remainder`). Enquiry functions are:
`sign? positive? negative? zero? even? odd? NaN?`. The unary minus function is only represented
by a prefix function `negate`, not by an operator, since these have always two arguments.
Lastly, there are functions for determining the absolute value (`absolute`),
the maximum and minimum of two numbers (`max min`) and for rounding (`round`).

The arguments and result types for these functions are as follows.
Result types are only indicated if different from argument types.
....
function                       argument type(s)                           result type

+ - * / // %                   number! time! char! pair! tuple! vector!
**                             number!
NaN?                           number!                                    logic!
sign?                          number! time!                              integer!
positive? negative?            number! time!                              logic!
zero?                          number! time! char! pair! tuple!           logic!
even? odd?                     number! char!                              logic!
negate                         number! time! pair!
absolute round                 number! time! pair!
max min                        number! time! char! series!
....

Note that not all combinations of argument types are allowed. In general, the types
`number! time! char!` are freely combinable. The operations on values of type
`pair! tuple! vector!` take place component-by-component where possible. The functions
`max min` applied to `series!` arguments do a lexicographic comparison.

=== Higher mathematical functions

This concerns first of all the familiar functions `exp` for raising
`e = 2.718281828459045` to a power, the logarithms `log-e log-2 log-10`,
and the square root `sqrt`. Furthermore the trigonometric functions
`sin cos tan asin acos atan atan2`, and the functions `random` and
`checksum`. The latter allows the following methods: `MD5 SHA1 SHA256 SHA384 SHA512 CRC32 TCP`.

The arguments and result types for these functions are as follows.
Result types are only indicated if different from argument types.
....
function                       argument type(s)                           result type

exp log-e log-2 log-10 sqrt    number!                                    float!
sin cos tan asin acos atan     float!
atan2                          float!
random                         number! time! char! pair! tuple!
checksum                       binary! string! file!                      binary!
....

Notes: all trigonometric functions take an argument in radians, except `atan2`
which takes two `float!` arguments representing `y` and `x` coordinates.
The function `random` is also defined for `series!` arguments. See section
_**Series manipulation**_.

=== Set-theoretical functions

The following functions operate on values that can be conceived as representing
_sets_ of other values; this concerns some series types: `block! hash! string!`,
as well as `bitset!` and `typeset!`.

The functions `intersect union difference` and `exclude` have two arguments
of one of the types mentioned, and yield a result of the same type. The function
`unique` has one argument of one of the types mentioned, and again yields
a result of the same type. The operation of these functions follows from their names.

=== Bitwise functions

The following functions operate on the bit patterns underlying Red values
of suitable types.

The function `complement` yields the bit-by-bit complement, thus for integers
it yields the two's complement, e.g. `complement 2` is `-3`.
The operators `and or xor` with prefix counterparts `and~ or~ xor~` operate
bit-by-bit on their arguments.

Three bit-shift operators are defined on integers:

* `<<` for left shift: highest bits are shifted out, zero bits are added to the right
* `>>` for right shift: lowest bits are shifted out, highest bit is duplicated
* `>>>` for "logical" shift: lowest bits are shifted out, zero bits are added to the left

The arguments and result types for these functions are as follows.
Result types are only indicated if different from argument types.
....
function                       argument type(s)                           result type

complement                     integer! bitset! typeset! binary!
and or xor                     integer! char! pair! tuple!
                               bitset! typeset! binary! vector!
<< >> >>>                      integer!
....

Note that `and or` and `xor` on values of type `bitset!` and `typeset!` yield
the same result as `intersect union` and `difference` (see previous section).  

=== Logical functions

The bitwise functions `complement and or xor` are also applicable to
`logic!` values; on these values, `not` is equivalent to `complement`.
On values of other types, `not` will always yield `false` except on
`none`, where it will yield `true`.

Note that `and or xor` evaluate both their arguments. In many programming
situations, it is preferable to use the _shortcut evaluation_ functions
`any` and `all`, which only evaluate subsequent arguments if an earlier one
is `false` or `none` for `any` or `not none` (i.e.`true`) for `all`.
See section _**Blocks: reduction and selective evaluation**_.

== Series manipulation

As explained earlier, series in Red, as values of indirect types, have their
components stored contiguously, but separately from the value slot that
stores the "series value" itself. This value slot only contains the following
information: a pointer to the components storage, and the current index.
The components storage itself keeps track of the length of the series
i.e. the index of the last component.

=== Positioning and navigation

The following functions of a series value yield a new series value with the index
modified:
....
function                 new index

head <series>            1
tail <series>            length + 1
at <series> <value>      <value>
skip <series> <value>    index + <value>
next <series>            index + 1
back <series>            index - 1
find <series> <value>    "index of first occurrence of <value>"
....

Here the `<value>` argument of `at` and `skip` is an integer. For `image!` values,
a `pair!` value is also allowed. This will be converted to a regular index.
The `<value>` argument of `find` may be a single component value or a sub-series.

For all series, if the index becomes smaller than 1 or greater than the length + 1,
it will be fixed at 1 or length + 1. If `find` does not have a match, its result is `none`.

The following enquiry functions are available: `head? tail? length? index?`. The function
`empty?` is a synonym for `tail?`. The built-in function `offset?` yields the difference
of the `index?` values of its two `series!` arguments. 

Note: for programming convenience, the functions `length?` and `empty?` (but not `tail?`)
accept `none` as an argument, yielding `none` as result.

=== Extraction and modification of components

The following functions have been described in section _**Components of values**_:
`pick poke select put first second third fourth fifth`.

The function `last` may be seen as shorthand for `first back tail`.

These functions create a new series value, with a new series value slot:
....
function                      result

copy <series>                 copy of the series
extract <series> <integer>    copy of the series with every nth component 
split <series> <delimiter>    a block of sub-strings split at the delimiter(s)
....

For `split`, the `<series>` must be of type `any-string!`, and the
`<delimiter>` may be a single character, a bitset representing
a choice of characters, or a string.

The following functions modify the series _in place_, i.e. they modify
the series value slot to point to the changed series. With the exception of
`take` and `alter`, their result is the series itself.
....
function                      operation                                 resulting position of series

reverse <series>              order of components reversed              at head
sort <series>                 components in increasing order            at head
random <series>               components in random order                at head
clear <series>                components removed till tail              at tail
remove <series>               current component removed                 unchanged, i.e. before next component
take <series>                 current component removed                 (unchanged, result is component value)
change <series> <value>       current component replaced by <value>     after current component
replace <series> <pattern>    components equal to <pattern>             at head
     <value>                  replaced by <value>
alter <series> <value>        if <value> in <series> remove it,         (at head, result is true if appended,
                              else append                               else false)
insert <series> <value>       insert <value> before current component   before current component                         
append <series> <value>       insert <value> at tail                    at head
repend <series> <value>       insert reduced <value> at tail            at head
trim <series>                 spaces removed from string                at head
pad <series>                  string padded on right side with spaces   at head
....

The following functions take two series as arguments:
....
function                      operation                                 result and position

swap <series> <series>        swap components at current positions      first series at head
move <series> <series>        remove current component of first series  first series before next component
                              and insert it before current component
                              of second one
max <series> <series>         compare series lexicographically          greater series before current component
min <series> <series>         compare series lexicographically          smaller series before current component
....

Note: for programming convenience, the following functions take `none` as argument, yielding `none` as result:
`clear find remove select take`.

== Control

=== Selective execution

The following functions enable conditional execution of one or more block:
`if unless either case switch`. The definitions may be presented as follows:

....
<if>          ::= if <condition> <true-block>
<unless>      ::= unless <condition> <false-block>
<either>      ::= either <condition> <true-block> <false-block>
<case>        ::= case [ <case-alt>* ] | case/all [ <case-alt>* ] 
<case-alt>    ::= <condition> <true-block>
<switch>      ::= switch <value> [ <switch-alt>* ]
                  | switch/default <value> [ <switch-alt>* ] <default-block>
<switch-alt>  ::= <label> <true-block> | <label> <switch-alt>
....

The `<condition>` is evaluated and is satisfied unless it yields `false` or `none`,
except for `unless`, where the condition _should_ yield `false` or `none`.

With refinement `/all`, all conditions of the `<case>` are tested; otherwise testing
stops after the first one that is satisfied, if any.

The `<label>` values of the `<switch>` are _not_ evaluated. The selection condition
is satisfied at the first alternative where the `<value>` is equal to a `<label>`.
With refinement `/default`, the `<default-block>` will be executed if none
of the conditions is satisfied.

The functions `if` `unless` `case` and `switch` without `/default` yield `none` if
no condition is satisfied.


=== Repeated execution (loops)

The available constructs are the following:
....
<forever>     ::= forever <body>
<while>       ::= while <condition> <body>
<until>       ::= until <condition>
<loop>        ::= loop <integer> <body>
<repeat>      ::= repeat <word> <integer> <body>
<foreach>     ::= foreach <counter> <series> <body>
<forall>      ::= foreach <word> <body>
<remove-each> ::= remove-each <counter> <series> <condition>
<condition>   ::= <block>
<counter>     ::= <word> | <block>
<body>        ::= <block>
....

Semantics:

* `forever`: the `<body>` is executed until an exception is encountered
(see section _**Exceptions**_).
* `while`: the `<condition>` is executed and if does not yield `false` or `none`,
the `<body>` is executed after which the `<condition>` is again executed etc.
* `until`: the `<condition>` is executed as long as it does not yield `false` or `none`.
* `loop`: the `<body>` is executed an integer number of times.
* `repeat`: the `<body>` is executed repeatedly with the `<word>` assuming values
from 1 to the integer. Note that the `<word>` is _not_ local to the loop,
i.e. there is no separate context for the `repeat` loop.
* `foreach`: the `<counter>` may be a word or a block of words. The `<body>` is executed
repeatedly with the word(s) being set to subsequent components of the series.
The word(s) are again not local to the loop.

Example:
....
foreach [name phone] ["John" "123-4567" "Mary" "345-6789"] [print [name phone]]
....
* `forall`: the `<body>` is executed repeatedly starting with the word referring
to the head of the series; on each subsequent iteration the word will refer to the
series at the next position (see `next` function in section _**Series manipulation**_).

Example:
....
b: [1 2 3 4 5 6]
forall b [if even? b/1 [print b/2]]
....
* `remove-each`: the `<condition>` is executed on each iteration, with the word(s)
of the `<counter>` being set as in `foreach`. If the condition is satisfied,
the components of the series that the word(s) currently refer to, are removed from the series.

The result of `forever` is that of the exception that causes its interruption.
For the other functions, unless an exception has occurred, the result is the unset value
for `while loop` and `remove-each`, and the result of the execution of the body
for the remaining ones.

=== Interrupting execution

The built-in functions `break continue exit return` are described
in section _**Exceptions**_.

The built-in functions `halt` and `quit` or `q` stop the execution
of the program. _**Difference??_** The built-in function `quit-return`
delivers its integer argument as status code back to the Operating System.

=== Special execution cases

The built-in function `comment` evaluates its argument and yields
the unset value as result. It is mostly used to insert multi-line
comments, with a multi-line string, or a block as argument. Care has to
be taken that the argument is a valid Red value, even though its
evaluation is intended to have no effect.

The built-in function `also` has two arguments. It evaluates both one after the
other, and yields the result of the first one.

== Input/output

=== Conversion from/to textual representation

The built-in function `load` will convert textual input (or its binary UTF-8 encoded
equivalent), specified as its argument, to one or more values by calling upon
the lexical/syntactic analysis facilities of the toolchain. The result is either one
value or a block of values.

There are two built-in functions for converting values to readable strings:
`form` will produce a basic representation intended for human readers, and `mold`
will produce strings that are guaranteed to re-produce the original values when
submitted to `load`. As stated in section _**Conversion of values (`to`)**_ the
operation of `form` is the same as that of `to-string` with the exception of
argument types `none! binary!` and `any-list!`. Especially values of the
last group of types, as well as values of types `vector!` and `object!`
merit special attention since the are converted to strings showing
the essentials without conserving type information.

Examples:
....
load "1"                  -> 1                      ; string analyzed as representing an integer
load "1 + 2"              -> [1 + 2]                ; load produces a block for more than one value
load "[1 2 3]"            -> [1 2 3]                ; one (grouped) value detected
load #{5B31203220335D}    -> [1 2 3]                ; same input as binary value

form ()                   -> ""                     ; unset! value
form #{414243}            -> "#{414243}"            ; to-string gives "ABC"
form [1 2 3]              -> "1 2 3"                ; block brackets omitted
form quote (1 2 3)        -> "1 2 3"                ; parens also omitted
form make hash! [1 2 3]   -> "1 2 3"                ; hash property not shown
form make vector! [1 2 3] -> "1 2 3"                ; vector property not shown
form object [a: 1]        -> "a: 1"                 ; object property not shown
mold [1 2 3]              -> "[1 2 3]"              ; load is guaranteed to recognize this
mold make hash! [1 2 3]   -> "make hash! [1 2 3]"   ; hash property conserved
mold make vector! [1 2 3] -> "make vector! [1 2 3]" ; vector property conserved
....

The built-in function `save` will apply `mold` to the value which is its
second argument. If the destination specified as its first argument is a string,
it will append the result of `mold` to that string. If the destination
is a `binary!` value, it will first create a UTF-8 encoded `binary!` value
out of the result of `mold` and append that value to the destination .
_**See issue #2668**_

For `block!` and `paren!` values (not `hash!` _**see issue #2686**_),
the user can control the way they are presented by `mold` by inserting
line feed characters (`U+000A`) before selected values. The built-in
function `new-line` with a `block!` or `paren!` first argument will
set a _new-line markerthe value slot of the current component of
its argument (if the second argument is `true`) or clear this marker
if the second argument is `false`.

Example:
....
b: [1 2 3 4]
forall b [new-line b true]
print mold b
....
gives
....
[
    1 
    2 
    3 
    4
]
....

The state of the new-line marker may be tested with the built-in function
`new-line?` which has a `block!` or `paren!` argument, and yields `true`
or `false`.

=== Conversion from/to other representations

The built-in functions `load` and `save` each have an `/as` refinement
with a `word!` argument: the value `none` indicates Red code (Red data)
and makes `load` and `save` operate as already described;
other values implemented are `png jpeg bmp gif`; for each of these values
`load` will accept binary data in the indicated format and yield an `image!`
value, and `save` will take an `image!` value and produce the encoded binary
value.

The necessary decoding and encoding routines are stored in `system/codecs`.
This is a block of pairs: `<word><object>`, where the `<word>` indicates
the encoding e.g. `jpeg`, and the corresponding `<object>` has the following
content:
....
    key             value type   content

    title           string!      (not filled in) 
    name            word!        'JPEG
    mime-type       block!       [image/jpeg]
    suffixes        block!       [%.jpg %.jpeg %.jpe %.jfif]
    encode          routine!     routine [img [image!] where [any-type!]][...]
    decode          routine!     routine [data [any-type!]][...]
....

=== Printing

The built-in function `prin` will take a value or a block of values
and send a string to the standard output device. In the case of
a single value the string is the result of applying `form` to the
result of evaluating the value; in the case of a block, the individual
components are evaluated and converted by `form` and separated by
single spaces. The built-in function `print` calls `prin` and outputs
a line feed afterwards.

The built-in function `probe` will call `mold` and then `print`, and
yield its argument as a result. This is useful for debugging intermediate
results; note that `print` itself will yield the unset value.

Examples:
....
print [1 + 2 3 + 4]    ; prints "3 7" and yields unset
probe [1 + 2 3 + 4]    ; prints "[1 + 2 3 + 4]" and yields [1 + 2 3 + 4]
....

=== File and Url I/O

The built-in function `read` will read a string from a file on an external
device which is indicated by a `file!` or `url!` value as its argument. The content
is assumed to be UTF-8 encoded unless the refinement `/as` is used,
which has a `word!` argument indicating the character encoding _**What is allowed??**_.
If the refinement `/lines` is used, the content will be split into lines
at the line feed character (`U+000A`); a preceding carriage return (`U+000D`),
if present, will be accounted for. If the refinement `/binary` is used,
the content will be read as a `binary!` value and not be decoded.

The built-in function `load` will not only accept a string or `binary!` value
as input, but also a `file!` or `url!` value indicating a text or binary file.
It will read the content of the file and treat it as indicated above. 

The built-in function `write` will send a string or `binary!` value which is
its second argument to a file on an external device which is indicated
by a `file!` or `url!` value as its first argument.  If the second argument
is not a string or `binary!` value, it will first be passed to `mold`.
The resulting string will be UTF-8 encoded (as by `to-binary`)
unless the refinement `/as` is used, which has a `word!` argument indicating
the character encoding _**What is allowed??**_.
If the refinement `/append` is used the output will be written at the end of the file.
If the refinement `/lines` is used, and the value to be written is a block,
the components of the block will be written with a line feed after every component.
The refinement `/binary` ensures that a line feed character (`LF`, `U+000A`)
present in the source is not translated to an OS-specific character combination
(e.g. `CRLF`, `U+000D + U+000A`) but is output as a single `LF`.

The built-in function `save` will not only accept a string or `binary!` value
as destination, but also a `file!` or `url!` value indicating a text or binary file.
It will send its result to that file.

TBD
....
R    browse
A    close
A    create
A    modify
A    open
A    open?
A    query
A    update
....

=== File system functions

A `file!` value may indicate either a file or a _directory_ (some
Operating Systems call this a _folder_). The conventions for
Red file names are:

* the device name, if any, and the names in the directory hierarchy
are separated by a `/` character (some operating systems use
the `\` character for the same purpose)
* a file name starting with a `/` character represents an _absolute path_,
otherwise the path is _relative_ to the _current working directory_
* a file name ending in a `/` character represents a directory
* the abbreviations `.` for current directory and `..` for one level
higher directory are honored; the built-in function `clean-path`
will do the necessary substitutions (_normalization_)

The built-in function `to-local-file` translates a Red `file!` value
into the appropriate string for the target OS. The built-in function
`to-red-file` will take a string indicating a file in the target OS
and produce the equivalent Red `file!` value. These functions will
not do normalization.

Examples: 
....
to-local-file %/C/Projects/Red/programs/ -> "C:\Projects\Red\programs\"
to-red-file "C:\Projects\Red\programs\"  -> %/C/Projects/Red/programs/
....

The current working directory is stored in `system/options/path`.

The following built-in functions deal with the file system:

* `exists?` will yield `true` if the file indicated by its `file!` argument
exists in the file system, and `false` otherwise
* `suffix?` yields the suffix (extension) of a file, or `none` if there is no suffix
* `dir?` will yield `true` if the `file!` value indicates a directory
and `false` otherwise
* `what-dir` will yield the current working directory as a `file!` value
* `cd` or `change-dir` will set the current working directory to the argument
which may be a `file!`, `word!` or `path!` value; the argument will first be
_normalized_
* `pwd` will print the current working directory
* `make-dir` will create the directory that is indicated by its `file!` argument;
if this contains more than one directory level, and the `/deep` refinement
is specified, the intermediate directory or directories will also be created
* `clean-path` will normalize its `file!` argument to an absolute path
where `.` and `..` are eliminated
* `split-path` will take a `file!` argument and yield a block of two
`file!` values: the last file or directory in the path, preceded by the
directory containing that file or directory (or `%./` if the argument
was a single file or directory)
TBD
....
A    delete
F    dir
F    dirize
F    list-dir
F    ll
F    ls
A    rename
....
=== Console functions

The _console prompt_ and the string preceding the result of the user input
are available as `system/console/prompt` and `system/console/result`. Their
initial values are `">> "` and `"== "` respectively.

The built-in function `ask` will print its argument at the console prompt
and wait for user input until a line feed (`U+000A`) is received;
the string before the line feed will be yield as result.

The built-in function `input` is shorthand for `ask ""`.

The built-in functions `read-clipboard` and `write-clipboard` 
return respectively set the clipboard content as a string.

== Exceptions

Two kinds of exceptions (exceptional situations which disturb the normal
evaluation process) may be distinguished: _error exceptions_  or _errors_,
which arise in the course of evaluation because of inappropriate (combinations
of) values, and _user exceptions_ that are raised or "thrown" on conditions
determined by the user. An intermediate case is the _user error_ which is
also raised on conditions determined by the user but which is treated
like an error value.

=== Errors

==== Composition

Errors are values of type `error!` that can be produced as a result of
any evaluation; they are specialized objects with a fixed number of fields,
that contain the necessary information for identifying the nature and the place
of the error. A prototype error value is contained in `system/standard/error`.
As also shown in section _**Components of values**_ the fields are:
....
name     type           content

code      integer!       unique identifying number
type      word!          characterizes a group of errors
id        word!          identifier for the error within the group       
arg1      any-type!      additional information for the error message
arg2      any-type!      id.
arg3      any-type!      id.
near      block!         program fragment
where     any-type!      value whose evaluation triggered the error 
stack     integer!       machine address
....

Any field except `type` and `id` can also be `none`. If `arg1` is `none`
`arg2` and `arg3` will also be none`; likewise, if `arg2` is `none`,
`arg3` will also be `none`.

The `type` field may contain one of the following words: `throw note syntax
script math access user internal`.

There is a fixed _repertoire_ of errors; identifying information
and (parametrized) error messages for each possible error are stored
in the object `system/catalog/errors`. This has the following sub-objects,
whose field names correspond to the contents of the `type` field
of the error value and which group related errors:
....
system/catalog/errors/...        code field  type field

throw                              0        "Throw Error"
note                             100        "note"
syntax                           200        "Syntax Error"
script                           300        "Script Error"
math                             400        "Math Error"
access                           500        "Access Error"
user                             800        "User Error"
internal                         900        "Internal Error"
....

As indicated in the table, each of the sub-objects has two fixed fields:
`code` which contains the base number for the codes of the individual
errors, and `type` which is a string that can be used in forming the
error message; this serves to sufficiently characterize the group.
Each sub-object has furthermore a number of fields, whose names
correspond to the `id` field of the error value, and which identify
the individual error. E.g. the `math` group has fields `zero-divide, overflow`
and `positive`. The contents of each of these fields is either a string,
which is a complete error message, or a block of strings and instances
of `:arg1, :arg2` and `:arg3`, which needs to be bound 
to the context of the error value, in order for the values of
`arg1` to `arg3` to be inserted; the block then can be used
to construct the error message. The full list of possible
errors is shown in section _**Errors list**_.

When the error value is produced,
the word which is the value of its `type` field is bound such that
it refers to the sub-object whose field name is that word;
also, the word which is the value of `id` field is bound such that
it refers to the error message (string or block) within that sub-object
whose field name is that word. Thus the following code will produce
the full message information for an error value, say `err`:
....
either err/arg1                             ; test if insertion is necessary
[
    reduce bind (get err/id) (in err 'id)   ; yields a block of strings and values
][
    get err/id                              ; yields a string
]
....

Note the use of the `in` built-in function to obtain the context of the
error value.

Examples:
....
system/catalog/errors/math is an object! of value:
     code             integer!  400 
     type             string!   "Math Error" 
     zero-divide      string!   "attempt to divide by zero" 
     overflow         string!   "math or number overflow" 
     positive         string!   "positive number required" 
system/catalog/errors/access is an object! of value:
     code             integer!  500 
     type             string!   "Access Error" 
     cannot-open      block!    ["cannot open:" :arg1] 
     invalid-utf8     block!    ["invalid UTF-8 encoding:" :arg1] 
     no-connect       block!    ["cannot connect:" :arg1 "reason: timeout"]
....

The `code` for each individual error is the base number + the ordinal number
of the error in the sub-object, e.g. for `no-connect` it is `502`.
_**Currently it is 504, is this correct?**_

==== Raising and interception

Errors are normally raised by the compiled code or by the interpreter,
as the case may be, but they can also be raised by evaluating a word
referring to an error value, by `make error! <spec>` or the built-in
function `cause-error`. The raising of an error will break off program
execution, unless it is intercepted by `try` or `attempt`.

The built-in function `try <block>` will execute the block and if there is
an error, it will yield that error value; otherwise it will yield the value
resulting from the execution. The built-in function `attempt <block>` will
apply `try` and if the result is an error value, it will yield `none`.

=== User exceptions

In contrast to errors, a user exception is not a value of the language,
but a call of a built-in function, which interrupst program execution
and may cause resumption at another place in the code, or result in
breaking off the execution like an unintercepted error does.

Three types of user exceptions exist:

* interruption of repeated execution (_loops_)
* interruption of function body execution
* "throws"

==== Interruption of loops

Red has a number of _loop_ constructs which cause repeated execution
of a block (see section _**Repeated execution**_).
In each of these, the block (_loop body_) may contain calls of the built-in functions
`break` and `continue`. A call of `break` will interrupt execution
of the body and resume directly after it. The result of `break` and thus
of the evaluation of the loop is the unset value. A call of `break/return <value>`
will yield the `<value>` as a result of evaluating the loop.
A call of `continue` will interrupt execution of the body and resume
at the end of the body, potentially resulting in further cycles of execution.
Calls of these functions outside a loop body raise an error.

==== Interruption of function body execution

A call of the built-in function `exit` will interrupt execution of the
function body and resume in the code directly after the call.
The result of `exit` is the unset value. A call of the built-in function
`return <value>` will also interrupt execution
and yield the `<value>` as a result of the function body execution.
Calls of these functions outside a function body raise an error.

==== Throws

A _throw_ is a call of the built-in function `throw <value>` which will
interrupt execution and resume just after a corresponding call
of the built-in function `catch`, yielding the `<value>` as a result.

A _catch_, i.e. a call of the built-in function `catch <block>`,
will execute the block and if there are no throws during the execution,
it will yield the result of the execution as a value. If within the block,
including within the body of any function called within the block,
to any depth, there is a throw, the result of the catch
will be the value yielded by this throw.

For more control, `throw` has a refinement `/name` with a `word!` argument.
Correspondingly, `catch` has a refinement `/name` with as argument
a word or a block of words. A _named throw_ will only be reacted on
by a _named catch_ which has (amongst others) this name as argument,
or by a catch without a name. Other encompassing `catch` calls
will let it pass through.

If a throw is not caught by a catch, it will result in an error. 

==== Interception by `try`

The built-in function `try` (see _**Raising and interception**_) has
a refinement `/all`, allowing it to catch all possible forms of exceptions,
including `break`, `continue`, `exit` and `return` misuses as well as
uncaught throws.

== Additional facilities

=== Preprocessor

The Red preprocessor is a dialect of Red, enabling transformation of Red source code
using a specific layer on top of regular Red language code. Transformations are achieved
by inlining preprocessor keywords (called _directives_) inside Red source code.

These directives will be processed:

* when the Red source code is compiled
* when the Red source code is executed by the `do` built-in function with a `file!` argument
* when the `expand-directives` built-in function is called on a `block!` value

The preprocessor is invoked after the lexical/syntactic analysis phase, so it processes
Red values, and not the source code in text form.

Directive categories:

* _conditional directives_: include code depending on the result of an expression
* _control directives_: control the behavior of the preprocessor.
* _macros_: transform code using functions, enables more complex transformations

Directives are denoted by specific `issue!` values (starting with a `#` character).

When a directive is processed, it is replaced by the resulting value it returns
(some directives do not return anything, so they are just removed).
That is how transformations of source code is achieved.

Note: Red/System has its own preprocessor, which is similar, but low-level
and applied to the source code in text form.

Further explanations are provided in separate documentation;
see section _**Additional documentation**_.

=== Parse

The _parse dialect_ is an embedded Domain Specific Language for parsing input series
using grammar rules. It is an enhanced member of the Top Down Parsing Languages (TDPL) family.
Parse's common usages are for checking, validating, extracting, modifying
input data and implementing embedded and external DSLs.

Parse's core principles are:

* advance input series by matching grammar rules until top-level rule failure
(returning `false`) or input exhaustion (returning `true )
* ordered choices (e.g. in `["a" | "ab"]` rule, the second one will never succeed)
* rules composability (unlimited)
* limited backtracking: only input and rules positions are backtracked,
other changes remain
* two modes: string-parsing (for example: external DSL) or block-parsing (for example: embedded DSL)

Further explanations are provided in separate documentation;
see section _**Additional documentation**_.

=== GUI System

The Red/View component is a graphic user interface system for the Red programming language.
The design goals are:

* data-oriented, minimal API
* tree of objects as programming interface
* realtime or deferred synchronization between the object tree and the display system
* make two-way binding trivial to support
* ability to have different backends, across different platforms
* support OS, third-party and custom widget sets
* low performance overhead

The virtual tree is built using _face objects_, i.e. objects derived from the standard
object `face!`. Each face object maps to a graphic component on the display in a two-way
binding. The built-in function `view` takes a face object as argument and displays it
together with all face objects depending on it. Face objects can be made directly
by the user (`make <object> ...`) or created by using the Visual Interface Dialect (VID)
which allows to specify each graphic element to display. VID code is processed by
the `layout` function.

Draw is a dialect (DSL) that provides a simple declarative way to specify 2D drawing operations.
Such operations are expressed as lists of ordered commands (using blocks of values),
which can be freely constructed and changed at run-time. Draw blocks can be rendered
directly as an `image!` value using the `draw` built-in function, or as a part of
a graphic element created by `view/layout`.

Further explanations are provided in separate documentation;
see section _**Additional documentation**_.

=== Reactivity

Red objects are capable of triggering asynchronous events in response
to changes in their components, thus enabling _reactive programming_.

The most prominent application of this in the toolchain is in the GUI engine
where the `face!` objects are reactors.

Further explanations are provided in separate documentation;
see section _**Additional documentation**_.

=== Environment and OS-related functions

The operation of these functions is dependent on the particular Operating System
(OS) running on the target computer.

The following functions allow interaction with the set of _environment variables_
that most Operating Systems maintain:

* `list-env` will yield a `map!` value with string keys and values for all variables
for the current process
* `get-env` with a string or word argument will yield the current value of the named variable
* `set-env` with a string or word argument and a string value as second argument will set
the named variable to the value, or unset it if the second argument in `none`

The function `now` yields the current date and time as a Red `date!` value _**for the moment
only `now/time` is available yielding the time as a Red `time!` valu**_.

The function `wait` with a `number!` or `time!` argument will wait for the specified time
or number of seconds.

The function `call` will execute an OS shell command to run another process. Its argument
is a `string!` value representing a shell command or a `file!` value representing
an executable file.

=== Help facilities

These facilities owe much to the homoiconicity of Red, and to the systematic
use of _docstrings_ (see section _**function! in Creation of values**_).

An overview of available facilities is obtained by typing `help` at the console.
This gives the following output:
....
    Use HELP or ? to view built-in docs for functions, values 
    for contexts, or all values of a given datatype:

        help append
        ? system
        ? function!

    To search for values by name, use a word:

        ? pri
        ? to-

    To also search in function specs, use a string:

        ? "pri"
        ? "issue!"

    Other useful functions:

        ??     - Display a variable and its value
        probe  - Print a molded value
        source - Show a function's source code
        what   - Show a list of known functions or words
        about  - Display version number and build date
....

== Pre-defined words list

=== constants
....
  characters
    comma
    CR
    dbl-quote
    dot
    escape
    lf
    newline
    null
    slash
    sp
    space
    tab
  floating point numbers
    pi
  logic! values
    false
    no     = false
    off    = false
    on     = true
    true
    yes    = true
  none! value
    none
  strings
    crlf
    font-fixed
    font-sans-serif
    font-serif
    p-indent
    value
  tuples (RGB color values)
    aqua
    beige
    black
    blue
    brick
    brown
    coal
    coffee
    crimson
    cyan
    forest
    glass
    gold
    gray
    green
    ivory
    khaki
    leaf
    linen
    magenta
    maroon
    mint
    navy
    oldrab
    olive
    orange
    papaya
    pewter
    pink
    purple
    reblue
    rebolor
    Red
    sienna
    silver
    sky
    snow
    tanned
    teal
    transparent
    violet
    water
    wheat
    white
    yello
    yellow
....
=== datatypes
....
    action!
    binary!
    bitset!
    block!
    char!
    datatype!
    email!
    error!
    event!
    file!
    float!
    function!
    get-path!
    get-word!
    handle!
    hash!
    image!
    integer!
    issue!
    lit-path!
    lit-word!
    logic!
    map!
    native!
    none!
    object!
    op!
    pair!
    paren!
    path!
    percent!
    point!
    refinement!
    routine!
    set-path!
    set-word!
    string!
    tag!
    time!
    tuple!
    typeset!
    unset!
    url!
    vector!
    word!
....
=== typesets
....
    all-word!
    any-block!
    any-function!
    any-list!
    any-object!
    any-path!
    any-string!
    any-type!
    any-word!
    default!
    immediate!
    internal!
    number!
    scalar!
    series!
....
=== functions

The functions are classified by functionality: 

* enquiry, i.e. properties of types and values (see sections
_**Type and typeset related functions**_ and _**Reflection on values**_)
* making values (see sections _**Creation of values**_ and _**Blocks: reduction and selective evaluation**_)
* converting values (see sections _**Conversion of values**_ and _**Casting of values**_)
* comparison (see section _**Conmparison of values**_)
* evaluation and binding (see sections
_**Words, contexts and binding**_ and _**Evaluation rules**_)
* numerical and logical computation (see section _**Numerical and logical computation**_)
* series manipulation (see section _**Series manipulation**_)
* control (see section _**Control**_)
* input/output (see section _**Input/output**_)
* exception handling (see section _**Exceptions**_)
* help facilities (see section _**Help facilities**_)
* preprocessor (see section _**Preprocessor**_)
* parse (see section _**Parse**_)
* GUI System (see section _**GUI System**_)
* reactivity (see section _**Reactivity**_)
* environment and OS-related (see section _**Environment and OS-related functions**_)

The letter in front of each word gives the type: `A` for `action!`, `N` for `native!`,
`O` for `op!`, `R` for `routine!` and `F` for `function!`. When a function is directly
derived from another one, the two are written on one line, and the most frequently
used one is written first.

==== enquiry
....
F    action?
F    any-block?
F    any-function?
F    any-list?
F    any-object?
F    any-path?
F    any-string?
F    any-word?
F    binary?
F    bitset?
F    block?
F    body-of
F    char?
F    class-of
N    complement?
N    context?
F    datatype?
F    email?
F    error?
R    event?
F    face?
F    file?
F    float?
F    function?
F    get-path?
F    get-word?
F    handle?
F    hash?
F    image?
F    immediate?
A    index?
F    integer?
F    issue?
F    keys-of
F    lit-path?
F    lit-word?
F    logic?
F    map?
F    native?
F    none?
F    number?
F    object?
F    op?
F    pair?
F    paren?
F    path?
F    percent?
F    refinement?
A    reflect
F    routine?
F    scalar?
F    series?
F    set-path?
F    set-word?
F    spec-of
F    string?
F    tag?
F    time?
F    tuple?
N    type?
F    typeset?
F    unset?
F    url?
F    values-of
F    vector?
F    word?
F    words-of
....
==== making values
....
F    charset
F    collect
N    compose
N    construct
F    context
N    does
N    extend
N    func
N    function
N    has
A    make
F    object
N    reduce
F    routine
....
==== converting values
....
N    as
R    as-color
R    as-ipv4
N    as-pair
R    as-rgba
N    debase
N    enbase
N    lowercase
A    to
F    to-binary
F    to-bitset
F    to-block
F    to-char
F    to-email
F    to-file
F    to-float
F    to-get-path
F    to-get-word
F    to-hash
F    to-image
F    to-integer
F    to-issue
F    to-lit-path
F    to-lit-word
F    to-logic
F    to-map
F    to-none
F    to-pair
F    to-paren
F    to-path
F    to-percent
F    to-refinement
F    to-set-path
F    to-set-word
F    to-string
F    to-tag
F    to-time
F    to-tuple
F    to-typeset
F    to-unset
F    to-url
F    to-word
N    uppercase
....
==== comparison
....
O    <        N    lesser?
O    <=       N    lesser-or-equal?
O    <>       N    not-equal?
O    =        N    equal?
O    ==       N    strict-equal?
O    =?       N    same?
O    >        N    greater?
O    >=       N    greater-or-equal?
....
==== evaluation and binding
....
N    all
N    any
N    bind
N    context?
N    do
N    get
N    in
A    index?
F    quote
N    set
N    unset
N    value?
....
==== numerical and logical computation
....
A    absolute
O    +           A    add
O    and         A    and~
F    acos        N    arccosine
F    asin        N    arcsine
F    atan        N    arctangent
F    atan2       N    arctangent2
N    checksum
A    complement
F    cos         N    cosine
O    /           A    divide
A    even?
N    exp
N    log-10
N    log-2
N    log-e
N    max
F    mod
O    //          F    modulo
O    *           A    multiply
N    min
N    NaN?
A    negate
N    negative?
N    not
A    odd?
O    or          A    or~
N    positive?
O    **          A    power
A    random
O    %           A    remainder
A    round
O    <<          R    shift-left    <- N shift/left
O    >>          R    shift-right   <- N shift
O    >>>         R    shift-logical <- N shift/logical
N    shift
N    sign?
F    sin         N    sine
F    sqrt        N    square-root
O    -           A    subtract
F    tan         N    tangent
O    xor         A    xor~
N    zero?
....
==== series manipulation
....
F    alter
A    append
A    at
A    back
A    change
A    clear
A    copy
F    empty?
F    extract
F    fifth
A    find
F    first
F    fourth
A    head
A    head?
A    index?
A    insert
F    last
A    length?
A    move
A    next
F    offset?
F    pad
A    pick
A    poke
A    put
A    random
F    rejoin
A    remove
F    repend
F    replace
A    reverse
F    second
A    select
A    sort
A    skip
F    split
A    swap
A    tail
A    tail?
A    take
F    third
A    trim
....
==== control
....
F    also
N    break
N    case
F    comment
N    continue
N    either
N    exit
N    forall
N    foreach
N    forever
F    halt
N    if
N    loop
F    q
F    quit
R    quit-return
N    remove-each
N    repeat
N    return
N    switch
N    unless
N    until
N    while
....
==== input/output
....
R    ask
R    browse
F    cd
F    change-dir
F    clean-path
A    close
A    create
R    create-dir
A    delete
F    dir
F    dir?
F    dirize
R    exists?
A    form
R    get-current-dir
F    input
F    list-dir
F    ll
F    load
F    ls
F    make-dir
A    modify
A    mold
N    new-line
N    new-line?
F    normalize-dir
A    open
A    open?
N    prin
N    print
F    probe
F    pwd
A    query
A    read
R    read-clipboard
A    rename
F    save
R    set-current-dir
F    split-path
F    suffix?
N    to-local-file
F    to-red-file
A    update
F    what-dir
A    write
R    write-clipboard
....
==== exception handling
....
F    attempt
N    catch
F    cause-error
N    throw
N    try
....
==== preprocessor
....
F    expand
F    expand-directives
....
==== parser
....
F    on-parse-event
N    parse
F    parse-trace
....
==== GUI system
....
F    center-face
F    clear-reactions
F    distance?
F    do-actor
F    do-events
F    do-file
F    draw
R    find-flag?
F    get-scroller
F    insert-event-func
F    layout
F    overlap?
F    remove-event-func
F    request-dir
F    request-file
F    request-font
F    set-focus
F    show
F    size-text
F    unview
F    view
F    within?
....
==== reactivity
....
O    is       F is~ (hidden)
F    react
F    react?
R    set-quiet
....
==== environment and OS-related
....
N    call
N    get-env
N    list-env
N    now
N    set-env
N    stats
N    wait
....
==== help facilities
....
F    ?
F    ??
F    about
F    help
F    source
F    what
....
== Errors list

The format in each sub-section is
....
type (code base)
    id -> string or block
    etc. 
....

=== Throw Errors
....
throw ( 0 )
    break -> "no loop to break"
    return -> "return or exit not in function"
    throw -> ["no catch for throw:" :arg1]
    continue -> "no loop to continue"
....
=== Notes
....
note ( 100 )
    no-load -> ["cannot load: " :arg1]
....
=== Syntax Errors
....
syntax ( 200 )
    invalid -> ["invalid" :arg1 "at" :arg2]
    missing -> ["missing" :arg1 "at" :arg2]
    no-header -> ["script is missing a Red header:" :arg1]
    no-rs-header -> ["script is missing a Red/System header:" :arg1]
    bad-header -> ["script header is not valid:" :arg1]
    malconstruct -> ["invalid construction spec:" :arg1]
    bad-char -> ["invalid character in:" :arg1]
....
=== Script Errors
....
script ( 300 )
    no-value -> [:arg1 "has no value"]
    need-value -> [:arg1 "needs a value"]
    not-defined -> [:arg1 "word is not bound to a context"]
    not-in-context -> [:arg1 "is not in the specified context"]
    no-arg -> [:arg1 "is missing its" :arg2 "argument"]
    expect-arg -> [:arg1 "does not allow" :arg2 "for its" :arg3 "argument"]
    expect-val -> ["expected" :arg1 "not" :arg2]
    expect-type -> [:arg1 :arg2 "field must be of type" :arg3]
    cannot-use -> ["cannot use" :arg1 "on" :arg2 "value"]
    invalid-arg -> ["invalid argument:" :arg1]
    invalid-type -> [:arg1 "type is not allowed here"]
    invalid-type-spec -> ["invalid type specifier:" :arg1]
    invalid-op -> ["invalid operator:" :arg1]
    no-op-arg -> [:arg1 "operator is missing an argument"]
    bad-op-spec -> {making an op! requires a function with only 2 arguments}
    invalid-data -> ["data not in correct format:" :arg1]
    invalid-part -> ["invalid /part count:" :arg1]
    not-same-type -> "values must be of the same type"
    not-same-class -> ["cannot coerce" :arg1 "to" :arg2]
    not-related -> ["incompatible argument for" :arg1 "of" :arg2]
    bad-func-def -> ["invalid function definition:" :arg1]
    bad-func-arg -> ["function argument" :arg1 "is not valid"]
    bad-func-extern -> ["invalid /extern value:" :arg1]
    no-refine -> [:arg1 "has no refinement called" :arg2]
    bad-refines -> "incompatible or invalid refinements"
    bad-refine -> ["incompatible refinement:" :arg1]
    word-first -> ["path must start with a word:" :arg1]
    empty-path -> "cannot evaluate an empty path value"
    invalid-path -> ["cannot access" :arg2 "in path" :arg1]
    invalid-path-set -> ["unsupported type in" :arg1 "set-path"]
    invalid-path-get -> ["unsupported type in" :arg1 "get-path"]
    bad-path-type -> ["path" :arg1 "is not valid for" :arg2 "type"]
    bad-path-set -> ["cannot set" :arg2 "in path" :arg1]
    bad-field-set -> ["cannot set" :arg1 "field to" :arg2 "datatype"]
    dup-vars -> ["duplicate variable specified:" :arg1]
    past-end -> "out of range or past end"
    missing-arg -> "missing a required argument or refinement"
    out-of-range -> ["value out of range:" :arg1]
    invalid-chars -> "contains invalid characters"
    invalid-compare -> ["cannot compare" :arg1 "with" :arg2]
    wrong-type -> ["datatype assertion failed for:" :arg1]
    invalid-refine-arg -> ["invalid" :arg1 "argument:" :arg2]
    type-limit -> [:arg1 "overflow/underflow"]
    size-limit -> ["maximum limit reached:" :arg1]
    no-return -> "block did not return a value"
    throw-usage -> "invalid use of a thrown error value"
    locked-word -> ["protected word - cannot modify:" :arg1]
    bad-bad -> [:arg1 "error:" :arg2]
    bad-make-arg -> ["cannot MAKE" :arg1 "from:" :arg2]
    bad-to-arg -> ["cannot MAKE/TO" :arg1 "from:" :arg2]
    invalid-spec-field -> ["invalid" :arg1 "field in spec block"]
    missing-spec-field -> [:arg1 "not found in spec block"]
    move-bad -> ["Cannot MOVE elements from" :arg1 "to" :arg2]
    too-long -> "Content too long"
    invalid-char -> ["Invalid char! value:" :arg1]
    parse-rule -> ["PARSE - invalid rule or usage of rule:" :arg1]
    parse-end -> ["PARSE - unexpected end of rule after:" :arg1]
    parse-invalid-ref -> ["PARSE - get-word refers to a different series!" :arg1]
    parse-block -> ["PARSE - input must be of any-block! type:" :arg1]
    parse-unsupported -> {PARSE - matching by datatype not supported for any-string! input}
    parse-infinite -> ["PARSE - infinite recursion at rule: [" :arg1 "]"]
    parse-stack -> "PARSE - stack limit reached"
    parse-keep -> "PARSE - KEEP is used without a wrapping COLLECT"
    parse-into-bad -> {PARSE - COLLECT INTO/AFTER expects a series! argument}
    invalid-draw -> ["invalid Draw dialect input at:" :arg1]
    invalid-data-facet -> ["invalid DATA facet content" :arg1]
    face-type -> ["VIEW - invalid face type:" :arg1]
    not-window -> "VIEW - expected a window root face"
    bad-window -> {VIEW - a window face cannot be nested in another window}
    not-linked -> "VIEW - face not linked to a window"
    not-event-type -> ["VIEW - not a valid event type" :arg1]
    invalid-facet-type -> ["VIEW - invalid rate value:" :arg1]
    vid-invalid-syntax -> ["VID - invalid syntax at:" :arg1]
    react-bad-func -> {REACT - /LINK option requires a function! as argument}
    react-not-enough -> {REACT - reactive functions must accept at least 2 arguments}
    react-no-match -> {REACT - objects block length must match reaction function arg count}
    react-bad-obj -> "REACT - target can only contain object values"
    react-gctx -> ["REACT - word" :arg1 "is not a reactor's field"]
    lib-invalid-arg -> ["LIBRED - invalid argument for" :arg1]
....
=== Math Errors
....
math ( 400 )
    zero-divide -> "attempt to divide by zero"
    overflow -> "math or number overflow"
    positive -> "positive number required"
....
=== Access Errors
....
access ( 500 )
    cannot-open -> ["cannot open:" :arg1]
    invalid-utf8 -> ["invalid UTF-8 encoding:" :arg1]
    no-connect -> ["cannot connect:" :arg1 "reason: timeout"]
....
=== User Errors
....
user ( 800 )
    message -> [:arg1]
....
=== Internal Errors
....
internal ( 900 )
    bad-path -> ["bad path:" arg1]
    not-here -> [arg1 "not supported on your system"]
    no-memory -> "not enough memory"
    wrong-mem -> "failed to release memory"
    stack-overflow -> "stack overflow"
    too-deep -> "block or paren series is too deep to display"
    feature-na -> "feature not available"
    not-done -> "reserved for future use (or not yet implemented)"
    invalid-error -> "error object or fields were not valid"
    routines -> {routines require compilation, from OS shell: `red -c <script.red>`}
    red-system -> {contains Red/System code which requires compilation}
....

== Metadata for the toolchain

It is recommended to organize the metadata as `<word>: <value>` pairs. This
will facilitate storage and retrieval of these data by the toolchain as well
as the user. Certain elements of metadata, that are used by the toolchain,
*must* be in this format: `Needs:` and `Config:`, with prescribed types for
the `<value>` as indicated.

The following is a list of suggested and compulsory elements.

....
element     type           description

Title:      string!        application title
Purpose:    string!        short description of the application purpose
Author:     string!        source code author name
File:       file!          name of the source file
Version:    tuple!         source code version
Date:       date!          date of last version
Rights:     string!        copyrights
License:    [url! string!] source license (URL or full text)
History:    block!         source modifications history
Note(s):    string!        any special notice

Language:   word!          language of the comments
Tabs:       integer!       number of spaces between tab positions
Icon:       file!          *.ico file with icon for executable

Needs:      [word! block!] module(s) that is/are to be included
Config:     ???
....

== Additional documentation

The following is a list of official documents that complement the information given in this one.

. https://github.com/red/red/blob/master/README.md[README file for the toolchain]
. http://static.red-lang.org/red-system-specs-light.html[Red/System Language Specification]
. https://doc.red-lang.org/en/[Red Programming Language Documentation] notably:
  .. https://doc.red-lang.org/en/map.html[map! datatype]
  .. https://doc.red-lang.org/en/gui.html[GUI System]
  .. https://doc.red-lang.org/en/reactivity.html[Reactive Programming]
  .. https://doc.red-lang.org/en/preprocessor.html[Preprocessor]
. https://github.com/red/red/blob/master/docs/conversion-matrix.xlsx[Conversion matrix]
. http://www.red-lang.org/2013/11/041-introducing-parse.html[Introducing Parse] (blog article from 2013)
