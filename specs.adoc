= Red Language Specification - draft
:imagesdir: /images
:toc:
:numbered:


== Codification

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter. The prefix letter can be:

* **`S`**: for syntactic rules.
* **`E`**: for evaluation rules.

== Syntax

Source input to Red must be UTF-8 encoded.

Values in Red are, in the vast majority of cases, separated by one or more whitespace characters.

In the context of Red source, whitespace characters are space (U+0020), tab (U+0009), line feed (U+000A), next line (U+0085) and non-breaking space (U+00A0).
^^^^^^^ This is most certainly short of some whitespace values, please correct See also issue #2492 ^^^^^^^^^^^^^^ 

In certain cases, where there can be no ambiguity, the requirement for whitespace between values can be relaxed. For example, it is possible to omit whitespace between two consecutive block! values and between word! values and block! values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?           [1234]         [1234]
     
=== Integer!

=== Float!

=== Char!

<char> :: = <viewable character> | <escaped-character> | <hexadecimal-codepoint> 

A char! value must be a valid single Unicode codpoint, i.e. an integer in the range 0 to 0x10FFFFF. 

<viewable-character> :: = #"????"

A <viewable character> is, in most cases, is simply a displayable character. For example, #"e", #Ã©", #"â‚¬" or #"ðŸ˜€". When a displayable character requires two or more graphemes to display a character, each grapheme requires a separate Red character. For example, when Ã© is encoded in its two character decomposed form e (U+0065) followed by the combining Â´ (U+0301) they cannot be combined into a single char! value.

<escaped character> :: =  #"^(null)| #"^@" | null | #"^(back)" | #"^H" | #"^(tab)" | #"^-" | #"^(line)" | #"^/" |
                          #"^(page)" | #"^L" | #"^M" | #"^(esc)" | #"^[" | #"^"" | #"^^" |  #"^(del)" | #"^~"

     Named Form   Short Form    Character           Codepoint
     #"^(null)    #"^@"         null                U+00
     #"^(back)"   #"^H"         backspace           U+08
     #"^(tab)"    #"^-"         horizontal tab      U+09
     #"^(line)"   #"^/"         new line            U+0A
     #"^(page)"   #"^L"         form feed           U+0C 
                  #"^M"         carriage return     U+0D
     #"^(esc)"    #"^["         escape              U+1B
                  #"^""         " - quote           U+22
                  #"^^"         ^ - caret           U+5E                
     #"^(del)"    #"^~"         delete              U+7F
  
  
<hexidecimal-codepoint> :: = "^(<hex> | <hex>>hex> | <hex><hex><hex> | <hex><hex><hex><hex>)"  

<hex> :: = 0-F0-F

=== ...

== Types

=== Type list

*TBD: Provide a table with all the datatypes and a brief description of their purpose.*

=== Type groups

=== Type hierarchy


== Binding

=== Contexts

=== Binding process


== Comparison

=== Equality

=== Strict equality

=== Sameness

=== Type ordering

=== Type comparisons


== Conversion


== Evaluation rules

`a -> b` will be used to signify evaluation relation, from value or type `a` to value or type `b`.

=== Passive types

**`E100`**:: For all values of type in `passive!` typeset: `value -> value`. This is called the **identity rule**.

=== Decaying types

**`E101`**:: `lit-word! -> word!`. Evaluating a `'word` value results in its `word` counterpart.

**`E102`**:: `lit-path! -> path!`. Evaluating a `'v0/v1/.../vn` value results in its `v0/v1/.../vn` counterpart.


=== Function types

==== Action! type

==== Native! type

==== Op! type

==== Function! type

==== Routine! type

==== Options and optional arguments


=== Word! type

=== Get-word! type

=== Paren! type

=== Path! type

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop


== Exceptions

=== Error exceptions

==== Creation

==== Propagation

==== Interception

=== User exceptions

==== Creation

==== Propagation

==== Interception

== Preprocessor


== Errors list
