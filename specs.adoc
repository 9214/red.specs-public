= Red Language Specification - draft
:imagesdir: /images
:toc:
:numbered:


== Codification

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter. The prefix letter can be:

* **`S`**: for syntactic rules.
* **`E`**: for evaluation rules.

== Syntax

Source input to Red must be UTF-8 encoded.

Values in Red are, in the vast majority of cases, separated by White Space.

In the context of Red source, White Space is one or more of space(U+20), tab(U+09), newline(U+0A) or non-breaking space(U+A0).
^^^^^^^ This is most certainly short of some whitespace values, please correct See issue #2492 ^^^^^^^^^^^^^^ 

In certain cases, where there can be no ambiguity, the requirement for whitespace between values can be relaxed. For example, it is possible to omit whitespace between two consecutive block! values and between word! values and block! values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?           [1234]         [1234]
     
=== Integer!

=== Float!

=== Char!

A char! value is of the form #"<valid Unicode codepoint>". 

A <valid Unicode codepoint> can be supplied as either a <single grapheme>, an <escaped character> or <hexidecimal digits>.

A <single grapheme> is, in most cases, is simply a displayable character. For example, #"e", #Ã©", #"â‚¬" or #"ðŸ˜€". When a displayable character requires two or more graphemes to display a character, each grapheme requires a separate character. For example, when Ã© is encoded in its two character decomposed form e (U+0065) followed by the combining Â´ (U+0301) they cannot be combined into a single char! value.

An <escaped character> is of the form ^ followed by a character with the following meanings:

     Named Form   Short Form    Character           Codepoint
     #"^(null)    #"^@"         null                U+00
     #"^(back)"   #"^H"         backspace           U+08
     #"^(tab)"    #"^-"         horizontal tab      U+09
     #"^(line)"   #"^/"         new line            U+0A
     #"^(page)"   #"^L"         form feed           U+0C 
                  #"^M"         carriage return     U+0D
     #"^(esc)"    #"^["         escape              U+1B
                  #"^""         " - quote           U+22
                  #"^^"         ^ - caret           U+5E                
     #"^(del)"    #"^~"         delete              U+7F
  
  
<hexidecimal digits> must be in one of the forms ^(hh), ^(hhhh) or ^(hhhhhh) or ^(hhhhhhhh). For example:

  #"^(65)" equivalent to #"e"
  #"^(E9)" equivalent to #"Ã©"
  #"^(20AC)" equivalent to #"â‚¬"
  #"^(01F600)" equivalent to #"ðŸ˜€"

=== ...

== Types

=== Type list

*TBD: Provide a table with all the datatypes and a brief description of their purpose.*

=== Type groups

=== Type hierarchy


== Binding

=== Contexts

=== Binding process


== Comparison

=== Equality

=== Strict equality

=== Sameness

=== Type ordering

=== Type comparisons


== Conversion


== Evaluation rules

`a -> b` will be used to signify evaluation relation, from value or type `a` to value or type `b`.

=== Passive types

**`E100`**:: For all values of type in `passive!` typeset: `value -> value`. This is called the **identity rule**.

=== Decaying types

**`E101`**:: `lit-word! -> word!`. Evaluating a `'word` value results in its `word` counterpart.

**`E102`**:: `lit-path! -> path!`. Evaluating a `'v0/v1/.../vn` value results in its `v0/v1/.../vn` counterpart.


=== Function types

==== Action! type

==== Native! type

==== Op! type

==== Function! type

==== Routine! type

==== Options and optional arguments


=== Word! type

=== Get-word! type

=== Paren! type

=== Path! type

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop


== Exceptions

=== Error exceptions

==== Creation

==== Propagation

==== Interception

=== User exceptions

==== Creation

==== Propagation

==== Interception

== Preprocessor


== Errors list
