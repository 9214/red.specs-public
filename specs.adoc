= Red Language Specification - draft
:imagesdir: /images
:toc:
:numbered:

== Introduction

The purpose of this document is to codify the lexical/syntactic and semantic rules
of the Red programming language, and thus to be the authoritative document for: 

* verifying implementation conformity
* tracking changes in the language design, including why changes were made
* acting as a reference for tests

== Overview

The purpose of Red is to formulate _computer programs_.
A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is constructed such that
the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

An important property of Red is that any Red program is an _ordered sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, interpretation of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_simple values_), or _syntactically_ (_grouped
values_).

A special category of values is formed by _words_, that play
a similar role to identifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below, any _word_ may be _bound_ to a value in some _context_.
Initially, some words are bound to certain values in the _global context_,
notably to _built-in functions_, _types_ (type names conventionally end in `!`)
and _constants_ such as the truth values: `true` and `false`, as well as `none`
("nil" or "null"in other languages). Evaluation of a bound word yields the value
it is bound to. Evaluation of an unbound word raises an error, or may yield
a special value "unset". The evaluation rules given below will state,
amongst others, how words can come to be bound to values in the course of
program execution.

== Conventions

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter.
The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Lexical  and syntactic rules

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to lexical analysis
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], #( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more whitespace characters. In the context of Red source, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`) and non-breaking space (`U+00A0`).

^^^^^^^ This is most certainly short of some whitespace values, please correct See also issue #2492 ^^^^^^^^^^^^^^ 

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive block!
values and between word! values and block! values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?           [1234]         [1234]

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described ^^^^at the appropriate point^^^^.

A formal grammar corresponding to the above presentation is given below. As usual,
`*` means zero or more instances. The comment to any production rule, which starts with the ; on the line,
states the type of the single or grouped values generated by this rule. Any non-terminal that is not
further defined in the grammar is explained in the individual sections thereafter.

**`S100`**:: program structure

    <program>  ::= <prologue> <value>*
    <prologue> ::= Red [ <value>* ]
    <value>    ::= <lexeme> | <group>
    <lexeme>   ::= <integer>            ; integer!
             | <float>                  ; float!
             | <integer>% | <float>%    ; percent!
             | <integer>x<integer>      ; pair!
             | <time>                   ; time!
             | <tuple>                  ; tuple!
             | <word>                   ; word!
             | '<word>                  ; lit-word!
             | <word>:                  ; set-word!
             | :<word>                  ; get-word!
             | /<word>                  ; refinement!
             | #<word>                  ; issue!
             | <char>                   ; char!
             | <string>                 ; string!
             | <file>                   ; file!
             | <url>                    ; url!
             | <email>                  ; email!
             | <tag>                    ; tag!
             | <binary>                 ; binary!
             | <path>                   ; path!
             | '<path>                  ; lit-path!
             | <path>:                  ; set-path!
             | :<path>                  ; get-path!
    <group>    ::= <paren>
             | <block>
             | <map>
             | <constructor>
    <paren> ::=    ( <value>* )         ; paren!
    <block> ::=    [ <value>* ]         ; block!
    <map> ::=      #( <value>* )        ; map! even number of values only
    <constructor> ::= #[ <value>* ]     ; reserved for general typed value constructor
                   			



=== <integer>

An `integer!` value is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation, e.g. `1'000`.
^^^^^^^Hexadecimal notation, eg FFh, is omitted as this is under discussion^^^^^^

=== <float>

A `float!` value is written as a signed floating point number in the range of the IEEE 754 binary64 format,
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`.
The number may be followed by `E` or `e` with a signed integer exponent on base 10,
e.g. `1E9` for `1'000'000'000.0`. Note that in this case, no decimal point is required.
 
=== <time>

....
    <time> ::= <hmsd> | +<hmsd> | -<hmsd>
    <hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
               <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any unsigned `<integer>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

=== <tuple>

A `tuple!` value is written as 3 to 12 `<integer>` values in the range `0..255` separated by dots `.`

E.g.: `192.168.1.2`, `255.255.128` 

=== <word>

A `word!` value is written as one or more characters from the entire Unicode range excluding control characters
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # % $ @ : ;`.
A `word!` value does not begin with `0-9` or `'`.

=== <char>

....
    <char> :: = #"<single-character>"
    <single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
....

A `char!` value must be a valid single Unicode code point, i.e. an integer in the range 0 to 10FFFFF (hexadecimal notation). 

A `<viewable character>` is, in most cases, is simply a displayable character. For example, `e`, `Ã©`, `â‚¬` or `ðŸ˜€`. When a displayable character requires two or more graphemes to display a character, each grapheme requires a separate Red character. For example, when `Ã©` is encoded in its two character decomposed form `e` (`U+0065`) followed by the combining `Â´` (`U+0301`) they cannot be combined into a single `char!` value.

....
    <escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) |
                          ^(esc) | ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
....

The correspondence between the escaped characters and Unicode code points is given in the table below.


     Named Form   Short Form    Character           Codepoint
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form (the beginning of)
an `<escaped-character>` or `<hexadecimal-codepoint>`. Thus e.g. `^3` yields the same as `3`.
     
....
    <hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....

where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

=== <string>

....
     <string> ::= "<single-character>*" | {<single-character>*}
....

When the `<string>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `}`
character that is part of the `<string`> must be escaped by preceding it with `^`. Within a `<string>`,
the same remark holds for `^` as noted above for a `<char>`. 

=== <file>

=== <url>

=== <email>

=== <tag>

=== <binary>

....
    <binary> ::= 2#{<base2-byte>*} | #{<hex>*} | 16#{<hex>*} | 64#{<base64-char>*}
....

where `<base2-byte>` is a group of 8 digits `0` or `1`, and `<base64-char>` is a single
character `A-Z a-z 0-9 + /`; the individual elements within the `#{ }` brackets (`<base2-byte>`,
`<hex>` or `<base64-char>`) may be separated from the brackets and from each other by whitespace.

=== <path>

== Types

=== Introduction

The types listed in rule `S100`, and whose values are specified in sections 4.1 to 4.13 are the only ones
that have lexically or syntactically determined values. The full list of types of the languages
is given in the next sub-section, with an explanation of the usage of their values.

Values that are not lexically or syntactically determined may be represented in programs by
expressions of the form `make <type> <spec>`, where `<type>` is a type name and `<spec>`
is a value that is interpreted by the `make` function as appropriate for the given type.

^^^^^^Mention general typed value constructor #[ <type> <value>* ] ^^^^^^^^^^^^

=== Type list

....
datatype!   
typeset!    
none!       
logic!      
float!      
percent!    
time!       
integer!    
char!       
pair!       
tuple!      
word!       
lit-word!   
set-word!   
get-word!   
refinement! 
issue!      
string!     
tag!        
url!        
file!       
email!      
vector!     
binary!     
image!      
block!      
hash!       
paren!      
path!       
lit-path!   
set-path!   
get-path!   
bitset!     
map!        
native!     
action!     
op!         
function!   
routine!    
object!     
error!      
unset!      
event!      
handle!     
....

=== Type categories

Red has a rather large number of different types. For a better understanding of their nature and that
of their values, it is useful to make a number of disctinctions into different categories.

* textual representation: types having lexically/syntactically representable values or not
  - among the first category: types with single values or grouped values
* internal representation: _direct types_ vs _indirect types_
* internal structure of values: _atomic types_ vs _composite types_
* evaluation: _passive types_, _decaying types_, _??? types_, _function types_

The first distinction has been treated in section 4. The other ones are treated
in the following sub-sections.

==== Direct/indirect types

==== Atomic/composite types

==== Types according to the evaluation of their values

=== Type hierarchy

For the convenience of the user, certain typesets have been predefined
which group related types. These will notably be used for indicating
the allowed types of arguments to polymorphic functions.

....
any-type!              
|-default              
| |-immediate!         
| | |-none!            
| | |-logic!           
| | |-scalar!          
| | | |-char!          
| | | |-number!        
| | | | |-integer!     
| | | | |-any-float!   
| | | | | |-float!     
| | | | | |-percent!   
| | | |-time!          
| | | |-pair!          
| | | |-tuple!         
| | |-any-word!        
| | | |-word!          
| | | |-lit-word!      
| | | |-set-word!      
| | | |-get-word!      
| | | |-refinement!    
| | | |-issue!         
| | |-datatype!        
| | |-typeset!         
| | series!            
| | |-any-block!       
| | | |-any-list!      
| | | | |-block!       
| | | | |-hash!        
| | | | |-paren!       
| | | |-any-path!      
| | | | |-path!        
| | | | |-lit-path!    
| | | | |-set-path!    
| | | | |-get-path!    
| | |-vector!          
| | |-any-string!      
| | | |-string!        
| | | |-file!          
| | | |-url!           
| | | |-tag!           
| | | |-email!         
| | |-binary!          
| | |-image!           
| |-bitset!            
| |-any-object!        
| | |-object!          
| | |-error!           
| |-map!               
| |-any-function!      
| | |-native!          
| | |-action!          
| | |-op!              
| | |-function!        
| | |-routine!         
|-internal!            
| |-unset!             
| |-event!             
| |-handle!            
....

== Binding

=== Contexts

=== Binding process


== Comparison

=== Equality

=== Strict equality

=== Sameness

=== Type ordering

=== Type comparisons


== Conversion


== Evaluation rules

`a -> b` will be used to signify evaluation relation, from value or type `a` to value or type `b`.

=== Passive types

**`E100`**:: For all values of type in `passive!` typeset: `value -> value`. This is called the **identity rule**.

=== Decaying types

**`E101`**:: `lit-word! -> word!`. Evaluating a `'word` value results in its `word` counterpart.

**`E102`**:: `lit-path! -> path!`. Evaluating a `'v0/v1/.../vn` value results in its `v0/v1/.../vn` counterpart.


=== Function types

==== Action! type

==== Native! type

==== Op! type

==== Function! type

==== Routine! type

==== Options and optional arguments


=== Word! type

=== Get-word! type

=== Paren! type

=== Path! type

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop


== Exceptions

=== Error exceptions

==== Creation

==== Propagation

==== Interception

=== User exceptions

==== Creation

==== Propagation

==== Interception

== Preprocessor


== Errors list
