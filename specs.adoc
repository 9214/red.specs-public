= Red Language Specification - draft
:imagesdir: /images
:toc:
:numbered:

== Introduction

The purpose of Red is to formulate _computer programs_.
A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is constructed such that
the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

An important property of Red is that any Red program is an _ordered sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, interpretation of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_simple values_), or _syntactically_ (_grouped
values_). A special category of values is formed by _words_, that play
a similar role to dentifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below: any _word_ may be _bound_ to a value in some _context_.

Initially, some words are bound to certain values in the _global context_,
notably to _built-in functions_, _types_ (type names conventionally end in !)
and _constants_ such as the truth values: `true` and `false`, as well as `none`
("nil" or "null"in other languages). Evaluation of a bound word yields the value
it is bound to. Evaluation of an unbound word raises an error, or may yield
a special value "unset".
The evaluation rules given below will state, amongst others, how words can come
to be bound to values in the course of program execution.

== Purpose

The purpose of this document is to specify, in as formal a manner as possible,
the lexical and syntactic make-up of Red programs, and the rules that govern their
evaluation.

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter. The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Lexical  and syntactic rules

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to lexical analysis
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], \#( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more whitespace characters. In the context of Red source, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`) and non-breaking space (`U+00A0`).

^^^^^^^ This is most certainly short of some whitespace values, please correct See also issue #2492 ^^^^^^^^^^^^^^ 

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive block!
values and between word! values and block! values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?           [1234]         [1234]

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described ^^^^at the appropriate point^^^^.

A formal grammar corresponding to the above presentation is given below. As usual,
`*` means zero or more instances. The comment to any production rule, which starts with the ; on the line,
states the type of the single or grouped values generated by this rule. Any non-terminal that is not
further defined in the grammar is explained in the individual sections thereafter.

    <program>  ::= <prologue> <value>*
    <prologue> ::= Red [ <value>* ]
    <value>    ::= <lexeme> | <group>
    <lexeme>   ::= <integer>            ; integer!
             | <float>                  ; float!
             | <integer>% | <float>%    ; percent!
             | <integer>x<integer>      ; pair!
             | <time>                   ; time!
             | <tuple>                  ; tuple!
             | <word>                   ; word!
             | '<word>                  ; lit-word!
             | <word>:                  ; set-word!
             | :<word>                  ; get-word!
             | /<word>                  ; refinement!
             | #<word>                  ; issue!
             | <char>                   ; char!
             | <string>                 ; string!
             | <file>                   ; file!
             | <url>                    ; url!
             | <email>                  ; email!
             | <tag>                    ; tag!
             | <binary>                 ; binary!
             | <path>                   ; path!
             | '<path>                  ; lit-path!
             | <path>:                  ; set-path!
             | :<path>                  ; get-path!
    <group>    ::= <paren>
             | <block>
             | <map>
             | <constructor>
    <paren> ::=    ( <value>* )         ; paren!
    <block> ::=    [ <value>* ]         ; block!
    <map> ::=      #( <value>* )        ; map! even number of values only
    <constructor> ::= #[ <value>* ]     ; reserved for general typed value constructor
                   			



=== <integer>

An `integer!` value is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation, e.g. `1'000`.
^^^^^^^Hexadecimal notation, eg FFh, is omitted as this is under discussion^^^^^^

=== <float>

A `float!` value is written as a signed floating point number in the range of the IEEE 754 binary64 format,
in decimal notation, possibly without decimal point. Leading zeroes are allowed, as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`).
The number may be followed by a signed integer exponent on base 10, after `E` or `e`, e.g. `1E9` for `1'000'000'000.0`.
 
=== <time>

....
    <time> ::= <hmsd> | +<hmsd> | -<hmsd>
    <hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
               <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any positive `<integer>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

=== <tuple>

A `tuple!` value is written as 3 to 12 `<integer>` values in the range `0..255` separated by dots `.`

E.g.: `192.168.1.2`, `255.255.128` 

=== <word>

A `word!` value is written as one or more characters from the entire Unicode range excluding control characters
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # % $ @ : ;`.
A `word!` value does not begin with `0-9` or `'`.

=== <char>

....
    <char> :: = #"<single-character>"
    <single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
....

A `char!` value must be a valid single Unicode code point, i.e. an integer in the range 0 to 10FFFFF (hexadecimal notation). 

A `<viewable character>` is, in most cases, is simply a displayable character. For example, `e`, `Ã©`, `â‚¬` or `ðŸ˜€`. When a displayable character requires two or more graphemes to display a character, each grapheme requires a separate Red character. For example, when `Ã©` is encoded in its two character decomposed form `e` (`U+0065`) followed by the combining `Â´` (`U+0301`) they cannot be combined into a single `char!` value.

....
    <escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) |
                          ^(esc) | ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
....

The correspondence between the escaped characters and Unicode code points is given in the table below.


     Named Form   Short Form    Character           Codepoint
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form an escaped character
as defined above. Thus e.g. `^3` yields the same as `3`
     
....
    <hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....

where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

=== <string>

....
     <string> ::= "<single-character>*" | {<single-character>*}
....

When the `<string>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `}`
character that is part of the `<string`> must be escaped by preceding it with `^`. Within a `<string>`,
the same remark holds for `^` as noted above for a `<char>`. 

=== <file>

=== <url>

=== <email>

=== <tag>

=== <binary>

=== <path>

== Types

=== Type list

*TBD: Provide a table with all the datatypes and a brief description of their purpose.*

=== Type groups

=== Type hierarchy


== Binding

=== Contexts

=== Binding process


== Comparison

=== Equality

=== Strict equality

=== Sameness

=== Type ordering

=== Type comparisons


== Conversion


== Evaluation rules

`a -> b` will be used to signify evaluation relation, from value or type `a` to value or type `b`.

=== Passive types

**`E100`**:: For all values of type in `passive!` typeset: `value -> value`. This is called the **identity rule**.

=== Decaying types

**`E101`**:: `lit-word! -> word!`. Evaluating a `'word` value results in its `word` counterpart.

**`E102`**:: `lit-path! -> path!`. Evaluating a `'v0/v1/.../vn` value results in its `v0/v1/.../vn` counterpart.


=== Function types

==== Action! type

==== Native! type

==== Op! type

==== Function! type

==== Routine! type

==== Options and optional arguments


=== Word! type

=== Get-word! type

=== Paren! type

=== Path! type

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop


== Exceptions

=== Error exceptions

==== Creation

==== Propagation

==== Interception

=== User exceptions

==== Creation

==== Propagation

==== Interception

== Preprocessor


== Errors list
